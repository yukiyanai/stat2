[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "KUT 統計学2",
    "section": "",
    "text": "1 はじめに\nこれは、高知工科大学 経済・マネジメント学群で開講されている「統計学2」（担当：矢内勇生）の講義用資料である。"
  },
  {
    "objectID": "index.html#sec-basicinfo",
    "href": "index.html#sec-basicinfo",
    "title": "KUT 統計学2",
    "section": "1.1 基本情報",
    "text": "1.1 基本情報\n\nシラバス（講義要項）：PDF\n講義スライド\n\n各授業の後に最新版をアップロードする\n\n\n\n\n\n\n\n\nWarning\n\n\n\n一般公開用のスライドでは一部の情報がカットされているので、正規受講生（単位を取得したい者）は [KUTLMS]https://lms.kochi-tech.ac.jp/course/view.php?id=2797) で完全版を入手すること\n\n\n\nKUTLMS\n\n登録キーはポータルで通知する\n\n授業用のSlackグループ\n\n登録 には大学ドメインのメールアドレスが必要"
  },
  {
    "objectID": "index.html#sec-refs",
    "href": "index.html#sec-refs",
    "title": "KUT 統計学2",
    "section": "1.2 教科書・副読本",
    "text": "1.2 教科書・副読本\n\n1.2.1 教科書\n\n浅野正彦, 矢内勇生. 2018.『Rによる計量政治学』オーム社（サポートページ）\n\n\n\n\n1.2.2 副読本\n\n宋財泫, 矢内勇生 （執筆中）『私たちのR：ベストプラクティスの探求』(web book、無料)"
  },
  {
    "objectID": "index.html#sec-topics",
    "href": "index.html#sec-topics",
    "title": "KUT 統計学2",
    "section": "1.3 講義トピックとウェブ資料の対応",
    "text": "1.3 講義トピックとウェブ資料の対応\n授業の内容は、10のトピックに分かれている。シラバス (PDF) にはトピックごとの予習課題と参考文献が記載されている。 各トピックとこのウェブ資料の対応は以下の通りである。\n\n\n\nトピック\nウェブ資料\n\n\n\n\n1. イントロダクション\n\n\n\n2. Quarto によるレポート作成\nQuartoによるレポート作成\n\n\n3. シミュレーション\n乱数生成\n\n\n\n中心極限定理\n\n\n4. 統計的推定と仮説検定の基礎\n統計的推定と仮説検定の基礎\n\n\n\n母集団と標本をシミュレーションで理解する\n\n\n5. 標本平均と母平均\nシミュレーションを利用して大数の法則を理解する\n\n\n\n標本分布を理解する\n\n\n\n母平均の推定\n\n\n6. \\(t\\) 分布と母平均の推定\n\\(t\\) 分布を利用した母平均の推定\n\n\n7. 2つの平均値を比較する\n統計的検定と平均値の比較\n\n\n8. 2つの変数の関係を理解する\n2変数の関係\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\n一部の例外を除いて、各ページ（各章）の内容を実行するために必要なパッケージはページの冒頭で読み込むことにする。ページの途中から実行しても動かないことがあると思われるので、その際はページの最初から実行してほしい。\n各ページは（パッケージのインストールとデータファイルの入手を除き）独立なので、ページ単位で実行することができる。"
  },
  {
    "objectID": "how2quarto.html#基本",
    "href": "how2quarto.html#基本",
    "title": "\n2  Quartoによるレポート作成\n",
    "section": "\n2.1 基本",
    "text": "2.1 基本\n基本的な使い方は統計学1の授業で解説済みなので、統計学1の資料で復習してほしい。『私たちのR』のQuarto入門にもう少し詳しい説明があるので、そちらも合わせて参照されたい。"
  },
  {
    "objectID": "how2quarto.html#文の修飾",
    "href": "how2quarto.html#文の修飾",
    "title": "\n2  Quartoによるレポート作成\n",
    "section": "\n2.2 文の修飾",
    "text": "2.2 文の修飾\n\n2.2.1 節の構成\n文の中に節 (section) や小節 (subsection) などを作りたいときは、#（ハッシュ）を使う。ハッシュの数が多くなるほど、下の階層が構成される。今、皆さんが見ている「Quartoによるレポート作成」という資料では、# Quartoによるレポート作成 がハッシュ1つの節であり、## 基本 や ## 文の修飾 などがハッシュ2つの小節、### 節の構成 がハッシュ3つの小小節 (subsubsection) である。YAMLヘッダのnumber-sections: を true にすると、「2」「2．1」などの番号が自動的に付される。番号を付けたくないときは、number-sections: false にする。\n\n\n\n\n\n\nWarning\n\n\n\nハッシュ記号の直後に半角スペースが1つ以上必要なので注意されたい。\n\n\n\n\n\n\n\n\nNote\n\n\n\nただし、この資料の場合、資料全体を「本 (book)」と考えると、「2」は節 (section) ではなく章 (chapter) である。レポート・論文を構成する区切りは1節、2節、3節 \\(\\dots\\) という節 (section) であり、それぞれの下の階層は 1.1節、1.2節などの小節 (subsection)、さらには1.1.1節などのsubsubsection である。\n\n\n\n2.2.2 文字の修飾\n文字を太字 (bold) にしたいときは、**太字**とすると太字になる。 また、イタリック（斜字体）にしたいときは、*italics* とすると italics になる。日本語をイタリックにはしない。 太字かつイタリックは、***bold italics***でbold italics になる。\nこれらの文字の修飾は、レポートや論文などでは使わない。\n\n2.2.3 箇条書き\n番号なしの箇条書きは、-、 +、 * で作る。記号の直後には半角スペースが必要である。\n例えば、\n- 項目1\n- 項目2\n    - 項目2.1\n    - 項目2.2\n- 項目3\nと入力すると、以下のように出力される。\n\n項目1\n項目2\n\n項目2.1\n項目2.2\n\n\n項目3\n\n番号付きの箇条書きは、1. のように、数字とドット（ピリオド）で作る。ドットの直後に半角スペースが必要である。数字は、全部1でもよいし、1.、2. などのように変えても良い。\n例えば\n1. 項目1\n1. 項目2\n    1. 項目2.1\n    1. 項目2.2\n1. 項目3\nと入力すると、以下のように出力される。\n\n項目1\n項目2\n\n項目2.1\n項目2.2\n\n\n項目3"
  },
  {
    "objectID": "how2quarto.html#r-コード",
    "href": "how2quarto.html#r-コード",
    "title": "\n2  Quartoによるレポート作成\n",
    "section": "\n2.3 R コード",
    "text": "2.3 R コード\nRコードは、基本的にコードチャンクの中に書く。コードチャンクとは、\n```{r}\n# ここにRのコードを書く。\n```\nというものであり、チャンクを挿入するキーボードショートカットは、\n\n\ncontrol + option + I (macOS)\n\nControl + Alt + I (Windows)\n\nである。\n各チャンクにチャンクオプションを付けることで、チャンクごとの挙動を制御することができる。 チャンクオプションは、#| という記号を使って、以下のように書く。\n```{r}\n#| echo: false \n#| eval: true\n#| message: false\n#| warning: true\n#| fig-height: 3\n#| fig-width: 5\n\n# ここにRコードを書く\n```\n上で書いたオプションは、\n\necho: コードを表示するかどうか。false で非表示。\neval: コードを実行するかどうか。false でコードを実行しない。\nmessage: コード実行時のメッセージを表示するかどうか。false で非表示。\nwarning: コード実行時の警告文を表示するかどうか。false で非表示。\nfig-height: 図の高さ。単位はインチ。\nfig-width: 図の幅。単位はインチ。\n\nこれら以外のチャンクオプションについては、公式ガイド を参照。"
  },
  {
    "objectID": "how2quarto.html#数式",
    "href": "how2quarto.html#数式",
    "title": "\n2  Quartoによるレポート作成\n",
    "section": "\n2.4 数式",
    "text": "2.4 数式\n\n2.4.1 数式・数学記号の基本\nQuartoでは、\\(\\LaTeX\\) と同じ方法で数式を書くことができる。\n\n\n\n\n\n\nNote\n\n\n\n\\(\\LaTeX\\) について詳しく知りたい者には、奥村晴彦, 黒木裕介. 2020.『LaTeX2\\(\\varepsilon\\) 美文書作成入門』（技術評論社）を参照されたい。\n\n\n文書の中に数式を入れたいときは、数式を書くためのコードを$で挟み、文書のなかに挿入する。 例えば、単純な足し算は $1 + 3 = 4$ と書くことで、\\(1 + 3 = 4\\) と表示される。あるいは、$Y_i = \\beta_0 + \\beta_1 X_i + \\varepsilon_i$ と書けば、\\(Y_i = \\beta_0 + \\beta_1 X_i + \\varepsilon_i\\) となる。\n数式を独立した行に表示したいときは、以下のようにする。\n$$\n\\bar{x} = \\frac{1}{N} \\sum_{n=1}^N x_n\n$$\nこれは、次のように表示される。 \\[\n\\bar{x} = \\frac{1}{N} \\sum_{n=1}^N x_n\n\\]\n複数行にわたる数式を書きたいときは、aligned 環境を使って以下のように書くことができる。\n$$\n\\begin{aligned}\n\\bar{x} \n &= \\frac{1}{N} \\sum_{n=1}^N x_n \\\\\n &= \\frac{1}{N} \\left(x_1 + x_2 + \\cdots + x_N \\right)\n\\end{aligned}\n$$\n上のコードでは、\\\\ で改行している。また、各行は & の位置で整列する。結果は次のようになる。 \\[\n\\begin{aligned}\n\\bar{x}\n&= \\frac{1}{N} \\sum_{n=1}^N x_n \\\\\n&= \\frac{1}{N} \\left(x_1 + x_2 + \\cdots + x_N \\right)\n\\end{aligned}\n\\]\n上の例からわかるとおり、分数は\\frac{分子}{分母}で書くことができる。\n数式でカッコを使うとき、() と [] はそのまま入力すればよいが、{}を使いたいときは \\{ や\\}のようにする必要がある。また、\\left( \\right) 、\\left\\{ \\right\\}、\\left[ \\right] のようにすると、カッコの中身に合わせてカッコの大きさを調節してくれる。例えば、\n$$\n(x - \\frac{1}{2})(y - \\frac{2}{\\frac{3}{31}})^2\n$$\nと入力すると、 \\[\n(x - \\frac{1}{2})(y - \\frac{2}{\\frac{3}{31}})^2\n\\] と表示されるが、\n$$\n\\left(x - \\frac{1}{2} \\right) \\left(y - \\frac{2}{\\frac{3}{31}} \\right)^2\n$$\nと入力すると、 \\[\n\\left(x - \\frac{1}{2} \\right) \\left(y - \\frac{2}{\\frac{3}{31}} \\right)^2\n\\] と、なる。\n下付きの添字は、_（アンダースコア）を使って、x_i と書くと、\\(x_i\\)のように表示される。 ただし、添字が2文字以上のときにx_23 のようにすると\\(x_23\\)となってしまうので、\\(x_{23}\\)にするためにはx_{23}とする。\n上付きの文字は、^（キャレット）を使ってx^aのように書くと、\\(x^a\\) のように表示される。 下付きの場合と同様に、2文字以上のときにはx^{a-b}のようにすると\\(x^{a-b}\\)となる。\n\n2.4.2 よく使う記号\nよく使う記号を以下に示す\n\n\n\n\n\n\n\nコード\n出力\n使用例\n\n\n\n\\times\n\\(\\times\\)\n\\(x \\times y\\)\n\n\n\\cdot\n\\(\\cdot\\)\n\\(x \\cdot y\\)\n\n\n\\cdots\n\\(\\cdots\\)\n\\(x_1 + x_2 + \\cdots + x_N\\)\n\n\n\\dots\n\\(\\dots\\)\n\\(a, b, \\dots, z\\)\n\n\n\\Pr(.)\n\\(\\Pr(.)\\)\n\\(\\Pr(X =x )\\)\n\n\n\\sum\n\\(\\sum\\)\n\\(\\sum (x_i - \\mu)^2\\)\n\n\n\\sum_{n = 1}^{N}\n\\(\\displaystyle \\sum_{n = 1}^{N}\\)\n\\(\\displaystyle \\sum_{n = 1}^{N} (x_n - \\bar{x})^2\\)\n\n\n\\prod\n\\(\\prod\\)\n\\(\\displaystyle \\prod_{n=1}^N x_n\\)\n\n\n\\sqrt{a}\n\\(\\sqrt{a}\\)\n\\(\\sqrt{xyz}\\)\n\n\n\\exp(.)\n\\(\\exp(.)\\)\n\\(\\exp(-\\lambda)\\)\n\n\n\\log(.)\n\\(\\log(.)\\)\n\\(\\log(2a)\\)\n\n\n\\partial\n\\(\\partial\\)\n\\(\\displaystyle \\frac{\\partial f(x, y)}{\\partial x}\\)\n\n\n\\int\n\\(\\int\\)\n\\(\\displaystyle \\int_{a}^b f(x) dx\\)\n\n\n\\lim\n\\(\\lim\\)\n\\(\\displaystyle \\lim_{n \\to \\infty} \\sum_{i=1}^n \\frac{1}{n!}\\)\n\n\n\\infty\n\\(\\infty\\)\n\n\n\n\\sim\n\\(\\sim\\)\n\\(X \\sim \\mbox{Normal}(\\mu, \\sigma)\\)\n\n\n\\to\n\\(\\to\\)\n\n\n\n\\binom{n}{k}\n\\(\\binom{n}{k}\\)\n\\(\\displaystyle \\binom{n}{k} = \\frac{n!}{k! (n-k)!}\\)\n\n\n\\bar{x}\n\\(\\bar{x}\\)\n\n\n\n\\hat{x}\n\\(\\hat{x}\\)\n\n\n\n\\widehat{abcde}\n\\(\\widehat{abcde}\\)\n\n\n\n\\tilde{x}\n\\(\\tilde{x}\\)\n\n\n\n\n2.4.3 ギリシャ文字\nギリシャ文字も数式環境の中で使える。文章中にギリシャ文字を入れたいときは、$と$の間に以下のコードを入力する（よく使うものだけ挙げる）。\n\n\n文字\nコード\n\n\n\n\\(\\alpha\\)\n\\alpha\n\n\n\\(\\beta\\)\n\\beta\n\n\n\\(\\gamma\\)\n\\gamma\n\n\n\\(\\mu\\)\n\\mu\n\n\n\\(\\sigma\\)\n\\sigma\n\n\n\\(\\lambda\\)\n\\lambda\n\n\n\\(\\phi\\)\n\\phi\n\n\n\\(\\pi\\)\n\\pi\n\n\n\\(\\delta\\)\n\\delta\n\n\n\\(\\epsilon\\)\n\\epsilon\n\n\n\\(\\varepsilon\\)\n\\varepsilon\n\n\n\\(\\nu\\)\n\\nu\n\n\n\\(\\xi\\)\n\\xi\n\n\n\\(\\zeta\\)\n\\zeta\n\n\n\nギリシャ文字の大文字の書き方は、以下の2つのパタンに分かれる。\n\nコードの1文字目を大文字にする\n\n例）\\(\\delta\\)の大文字\\(\\Delta\\) は \\Delta\n\n例）\\(\\phi\\)の大文字\\(\\Phi\\) は \\Phi\n\n\n\nアルファベットの大文字をそのまま使う。\n\n例）\\(\\alpha\\)の大文字AはA\n\n例）\\(\\beta\\)の大文字BはB\n\n\n\n\n注意：\n\n和算の記号\\(\\sum\\) は\\Sigmaではなく、\\sum\n\n\n\\sum: \\(\\sum\\)\n\n\n\\Sigma: \\(\\Sigma\\)\n\n\n\n乗算の記号\\(\\prod\\)は\\Pi はなく\\prod\n\n\n\\prod: \\(\\prod\\)\n\n\n\\Pi: \\(\\Pi\\)"
  },
  {
    "objectID": "how2quarto.html#図表",
    "href": "how2quarto.html#図表",
    "title": "\n2  Quartoによるレポート作成\n",
    "section": "\n2.5 図表",
    "text": "2.5 図表\n単に図を表示させるなら、ggplot()で作った図を plot() で示せばよい。\n\nD &lt;- tibble(x1 = rnorm(1000),\n            x2 = rnorm(1000, mean = -10, sd = 2))\np1 &lt;- ggplot(D, aes(x = x1, y = after_stat(density))) +\n    geom_histogram(color = \"black\") +\n    labs(x = expression(x[1]),\n         y = \"確率密度\")\nplot(p1)\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\nチャンクオプションを使うことによって、表示する図の大きさを変えたり、図に通し番号とキャプションを付けたりすることができる。 例えば、\n```{r}\n#| message: false\n#| fig-width: 6\n#| fig-height: 3\n#| fig-cap: \"$x_1$のヒストグラム\"\n#| label: fig-hist-x1\nplot(p1)\n```\nと書けば、以下のようになる。\n\nplot(p1)\n\n\n\n図 2.1: \\(x_1\\)のヒストグラム\n\n\n\n図 (figure) のラベルは、必ずfig-から始まるようにする。上の例では、fig-hist-x1がラベルである。ラベルを付けておくと、文章中でその図に言及する際、「@fig-hist-x1は〜」と書くと、「図 2.1 は〜」のように表示される。この番号は自動で付される。\n試しにもう1つ図を作って表示してみよう。まずは、図を作る。\n\np2 &lt;- ggplot(D, aes(x = x2, y = after_stat(density))) +\n    geom_histogram(color = \"black\") +\n    labs(x = expression(x[2]),\n         y = \"確率密度\")\n\nこの図を、以下のコードで表示する。\n```{r}\n#| message: false\n#| fig-width: 5\n#| fig-height: 5\n#| fig-cap: \"$x_2$のヒストグラム\"\n#| label: fig-hist-x2\nplot(p2)\n```\n以下の結果が得られる。\n\nplot(p2)\n\n\n\n図 2.2: \\(x_2\\)のヒストグラム\n\n\n\n「@fig-hist-x2 は\\(x_2\\)のヒストグラムである」と書けば、「図 2.2 は\\(x_2\\)のヒストグラムである」というように、自動的に正しい図番号が示される。\n表についても、図と同様にラベルをつけて、自動的に番号を付すことができる。 Markdown での表は、次のようにして作ることができる。\n| 列1      | 列2      | 列3      |\n| :-----   | :-----:  | -----:   |\n| $x_{11}$ | $x_{12}$ | $x_{13}$ |\n| $x_{21}$ | $x_{22}$ | $x_{23}$ |\n\n: Markdown で表を作る例 {#tbl-mdtable1 .striped}\n\n\n表 2.1: Markdown で表を作る例\n\n列1\n列2\n列3\n\n\n\n\\(x_{11}\\)\n\\(x_{12}\\)\n\\(x_{13}\\)\n\n\n\\(x_{21}\\)\n\\(x_{22}\\)\n\\(x_{23}\\)\n\n\n\n\n:--- の列は左揃え、:---: は中央揃え、---: は右揃えである。表の下の : の後に表 (table) のキャプションをつけることができる。その後の{}の中に#tbl- から始まるラベルをつけることができる。.striped はオプションで、これをつけると表の背景の色が、白とグレーが交互に現れるストライプになる。\n「@tbl-mdtable1 は Markdownで表を作る例である」と書くと、「表 2.1 は Markdownで表を作る例である」と表示される。\nRのコードで表を作ることもできる。 例えば、\n```{r}\n#| tbl-cap: \"Rで表を作る例\"\n#| label: tbl-Rtable\n#| echo: false\nD |&gt; \n  head() |&gt; \n  knitr::kable()\n```\nと書くと、以下のようになる。\n\n\n\n\n表 2.2: Rで表を作る例\n\nx1\nx2\n\n\n\n-0.2788004\n-9.669613\n\n\n0.0399019\n-10.729475\n\n\n-0.2332952\n-5.895507\n\n\n1.0039462\n-10.446513\n\n\n0.1779112\n-13.815952\n\n\n0.4661605\n-11.515518\n\n\n\n\n\n\n先程と同様、「@tbl-Rtable はRで表を作る例である」と書くと、「表 2.2 は Rで表を作る例である」と表示される。\nRコードでの表の作り方については、必要になったときにもう少し詳しく説明する。"
  },
  {
    "objectID": "rng.html#sec-prep7",
    "href": "rng.html#sec-prep7",
    "title": "\n3  乱数生成\n",
    "section": "\n3.1 準備",
    "text": "3.1 準備\n必要なパッケージを読み込む。\n\nlibrary(tidyverse)\n\n次に、日本語が正しく表示されるようにする。\n\n## 図のなかで日本語を使えるようにする\n## フォントの設定はお好みで\n## （Unix/Linux ではIPAexフォントのインストールが必要かも）\nif (.Platform$OS.type == \"windows\") { # Windows\n  library(fontregisterer)\n  my_font &lt;- \"Yu Gothic\"\n} else if (capabilities(\"aqua\")) { # macOS\n  my_font &lt;- \"HiraginoSans-W3\"\n} else { # Unix/Linux\n  my_font &lt;- \"IPAexGothic\"\n}\ntheme_set(theme_gray(base_size = 9,\n                     base_family = my_font))"
  },
  {
    "objectID": "rng.html#sec-rng",
    "href": "rng.html#sec-rng",
    "title": "\n3  乱数生成\n",
    "section": "\n3.2 乱数の生成",
    "text": "3.2 乱数の生成\nRを使って乱数 (random numbers) を生成しよう。\n\n3.2.1 コイン投げ\n自分で決めた特定の対象から、ランダムにどれかを選びたいときは、sample() 関数を利用する。たとえば、この関数を使ってコイン投げを実行したいときは、\n\ncoin &lt;- c(\"表\", \"裏\")  # コインを定義する\nsample(coin, size = 1)\n\n[1] \"表\"\n\n\nとする。size で何回選ぶか（何回コインを投げるか）を指定している。\nこれを何度か実行してみよう。\n\nsample(coin, size = 1)\n\n[1] \"裏\"\n\nsample(coin, size = 1)\n\n[1] \"裏\"\n\nsample(coin, size = 1)\n\n[1] \"裏\"\n\nsample(coin, size = 1)\n\n[1] \"表\"\n\nsample(coin, size = 1)\n\n[1] \"表\"\n\n\n選ぶ回数を変えてみよう。\n\nsample(coin, size = 2)\n\n[1] \"表\" \"裏\"\n\n\nもう一度やってみよう。\n\nsample(coin)\n\n[1] \"裏\" \"表\"\n\n\nさらに、もう一度やってみよう。\n\nsample(coin, size = 2)\n\n[1] \"表\" \"裏\"\n\n\nこれを何度やっても、1回目が表なら2回目は裏、1回目が裏なら2回目が表になる。つまり、2回目のコイン投げはランダムではない。これは、sample() が決められた対象から1つずつ順番に選ぶという作業をしているためである。私たちが定義した coin の中身は「表」と「裏」の2つしかない。この2つから順番に選ぶ作業をすると、1つ目に表（裏）が出れば、2回目に残されているのは裏（表）だけなので、2回目がランダムではなくなってしまう。\n試しに選ぶ回数を3回にしてみよう。\n\nsample(coin, size = 3)\n\nError in sample.int(length(x), size, replace, prob): cannot take a sample larger than the population when 'replace = FALSE'\n\n\nエラーが出た。選ぶ対象が2つしかないのに3つは選べないのでエラーになる（エラーをよく読むと、そのように書いてある）。\nしたがって、sample() を使ってコイン投げを2回以上行うには、少し工夫が必要になる。sample() は私たちが特に指示をしないと非復元抽出（sampling without replacement）を行う。非復元抽出というのは、1度選んだものは選択肢から外すという選び方である。何度もコイン投げを繰り返すには、復元抽出 (sampling with replacement) を行えばよい。復元抽出では、1度選んだものも選択肢の中に戻す（選択肢として復元する）という選び方である。 sapmle() で復元抽出を実行するために、replace = TRUE という指示を加える。\n\nsample(coin, size = 5, replace = TRUE)\n\n[1] \"表\" \"裏\" \"裏\" \"表\" \"裏\"\n\n\nこれでコイン投げを複数回実行できる。\n試しにコインを10回投げて、その結果を coin10 という名前で保存してみよう。（%&gt;% print()は結果を表示するためにつけているだけなので、結果を表示する必要がないならなくてもよい。）\n\ncoin10 &lt;- sample(coin, size = 10, replace = TRUE) %&gt;% \n  print()\n\n [1] \"表\" \"表\" \"表\" \"裏\" \"表\" \"表\" \"表\" \"表\" \"表\" \"表\"\n\n\n10回のうち、表は何回出ただろうか？Rを使って数えてみよう。数えるために、以下の方法をとる。\n\n特定のコイン投げ（1回目, 2回目, \\(\\dots\\), 10回目）が表だったかどうか調べる\n表の回数を数える\n\nRである特定の値（数または文字列）になっているか調べたいときは、== （二重等号）を使う。\n\n\n\n\n\n\nWarning\n\n\n\n= [等号1つ] は &lt;- と同じで右側の内容を左側に保存してしまうので注意。\n\n\n「二重等号の左側は右側と同じかどうか」を調べ、同じときは TRUE（真）、異なるときは FALSE（偽）という答えが返ってくる。簡単な例で確認してみよう。\n\na &lt;- 2    # aに2を代入する\na == 2\n\n[1] TRUE\n\na == 3\n\n[1] FALSE\n\na == \"裏\" # 文字列と比べるときは文字列を引用符で囲む\n\n[1] FALSE\n\n\nこれを使って、上で行った10回のコイン投げが表だったかどうか確かめよう。\n\ncoin10 == \"表\"\n\n [1]  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n\n\nこのように、各回について、表 (TRUE) か裏 (FALSE) かを教えてくれる。\n私たちは表が何回出たかを知りたいので、TRUE の回数を数えればいい。ここでは、10回しか投げていないので、自力で数えることもできるが、数が増えると数えるのは面倒である。そこで、Rを使って数える。Rでは TRUE と FALSE を数として扱うと、TRUE は 1、FALSE は0 とみなされる。したがって、TRUEの数を数えたいなら、上の結果を合計すればよい。合計は sum() で求められるので、次のようにする。\n\nsum(coin10 == \"表\")\n\n[1] 9\n\n\n表は10回中9回だったことがわかる。\n\n3.2.2 サイコロ投げ\n同じ関数を使って、サイコロ (die) 投げを実行してみよう。 まずは、サイコロを定義する。\n\ndie &lt;- 1:6  # 1から6までの整数\n# 以下のような書き方も可能\n# die &lt;- c(1, 2, 3, 4, 5, 6)\n# die &lt;- seq(from = 1, to = 6, by = 1)\n\nこれを復元抽出すれば、サイコロ投げを何度も行える。100回投げてみよう。\n\ndie100 &lt;- sample(die, size = 100, replace = TRUE)\n\n3は何回出ただろうか？\n\nsum(die100 == 3)\n\n[1] 16\n\n\n16回出たことがわかる。\nここまでは、「正しいコイン (a fair coin)」や「正しいサイコロ (a fair die)」を想定してきたが、特定の目が出やすいサイコロ（やコイン）を使うこともできる。「1が出る確率だけ他の目の4倍」というサイコロを1,000回投げてみよう。そのために、prob で各目が出る比率を指定する（確率を指定してもよい）。\n\nunfair1000 &lt;- sample(die, \n                     size = 1000, \n                     replace = TRUE,\n                     prob = c(4, 1, 1, 1, 1, 1))\n\n1が何回出たか確かめてみよう。\n\nsum(unfair1000 == 1)\n\n[1] 452\n\n\n1,000回のうち、452回1の目が出たことがわかる。\nこのように、それぞれの選択肢が選べる確率を自由に設定して実験することができる。\nまた、選ぶ対象も自由に設定できる。たとえば、\n\nsample(c(\"高知工科大\", \"高知県立大\", \"高知大\"), \n       size = 1, \n       replace = TRUE, \n       prob = c(3, 2, 1))\n\n[1] \"高知県立大\"\n\n\nのようなこともできる。\n実習課題 (1)\n\n1から6までの目がある「正しい」サイコロを2個振るという作業を1,000回繰り返し、出た目の合計が9になる回数を数えてみよう。\n「正しくない」コイン（表が出る確率が0.5ではないコイン）を500回投げ、表が出た回数を数えよう。表が出る確率は自由に設定してよい（ただし、0, 0.5, 1 を除く）。"
  },
  {
    "objectID": "rng.html#sec-probdist",
    "href": "rng.html#sec-probdist",
    "title": "\n3  乱数生成\n",
    "section": "\n3.3 確率分布からの乱数生成",
    "text": "3.3 確率分布からの乱数生成\nRでは、代表的な確率分布から乱数を生成することが可能である。基本的には、 r（randomの頭文字）と、分布名の最初の数文字を組み合わせた関数を使う。\n\n3.3.1 一様分布\n一様分布 (uniform distribution) からの乱数生成には、runif() を使う。この関数では、以下の3つの引数（ひきすう）を指定する。\n\n\nn: 生成する乱数の個数（必ず指定する）\n\nmin: 最小値（指定しないと 0 に設定される）\n\nmax: 最大値（指定しないと 1 に設定される）\n\n\n\n\n\n\n\nNote\n\n\n\nrunif()の min = 0や max = 1 などのように、引数を指定しないときに自動的に設定される値を既定値またはデフォルト (default value) と言う。「runif() 関数の min のデフォルトは0である」のような言い方をするので、覚えておこう。\n\n\n時計のように1から12（12は0とも考えらえる）の数字が書いてあるような円盤の上でランダムにルーレットを回すことを考える。そうすると、0から12の間のどの位置にルーレットが止まる確率も等しいと考えられる。このような状況を、最小値が0で最大値が12の（連続な）一様分布（連続一様分布; continuous uniform distribution）で表すことができる。このルーレットを100回使ってみよう。\n\na1 &lt;- runif(n = 100, min = 0, max = 12)\n\n結果をヒストグラムにしてみよう。\n\ndf1 &lt;- tibble(a1)  # 結果をデータフレーム (tibble) に入れる\nh1 &lt;- ggplot(df1, aes(x = a1)) +\n  geom_histogram(binwidth = 1, \n                 boundary = 0,\n                 fill = \"royalblue\", \n                 color = \"black\") +\n  labs(x = \"時計盤上のルーレットからの乱数\", \n       y = \"度数\") +\n  scale_x_continuous(breaks = 0 : 12)  # x軸の目盛を調整\nplot(h1)\n\n\n\n\n乱数の個数を増やしてみよう。\n\na2 &lt;- runif(n = 10000, min = 0, max = 12)\ndf2 &lt;- tibble(a2)\nh2 &lt;- ggplot(df2, aes(x = a2)) +\n  geom_histogram(binwidth = 1, \n                 boundary = 0,\n                 fill = \"royalblue\", \n                 color = \"black\") +\n  labs(x = \"時計盤上のルーレットからの乱数\", \n       y = \"度数\") +\n  scale_x_continuous(breaks = 0 : 12)  # x軸の目盛を調整\nplot(h2)\n\n\n\n\n連続ではない一様分布（離散一様分布; discrete uniform distribution）からの乱数は、上で使った sample() で生成することができる。「正しいサイコロ」投げは、「1から6までの整数の（非連続な）一様分布」である。\n\na3 &lt;- sample(1 : 6, size = 100000, replace = TRUE)\ndf3 &lt;- tibble(a3)\np3 &lt;- ggplot(df3, aes(x = a3)) +\n  geom_bar(width = 0.5) +\n  labs(x = \"出た目\", y = \"回数\") +\n  scale_x_continuous(breaks = 1 : 6)\nplot(p3)\n\n\n\n\n\n3.3.2 二項分布\nコイン投げの結果は、表か裏の2パタン（通常、「成功」と「失敗」と呼ばれる。コイン投げでは、表と裏のどちらを成功と呼んでもよいが、ここでは表を成功、裏を失敗としておく）しかない。また、同じコインを何度か投げることを繰り返すとき、1回1回のコイン投げで表が出る確率は一定であると考えられる。\nこのように、結果が成功と失敗の2種類のみで、成功確率が \\(\\theta\\) で一定（したがって、失敗確率は “\\(1-\\theta\\)” で一定）であるような試行を \\(N\\) 回繰り返したとき、その成功回数の分布を、「試行回数 \\(N\\) で成功確率 \\(\\theta\\) の二項分布 (binomial distribution)」と呼ぶ。\n理論的には、二項分布の平均値（期待値）は \\(N \\theta\\)、分散は \\(N \\theta (1 - \\theta)\\) になる。したがって、標準偏差は \\(\\sqrt{N \\theta (1 - \\theta)}\\) になる。また、最小値は0（1ではないので注意）、最大値は \\(N\\) である。\nたとえば、「試行回数5で成功確率0.3の二項分布」の平均値は\\(5 \\cdot 0.3 = 1.5\\)、分散は \\(5 \\cdot 0.3 (1 - 0.3) = 1.05\\)、標準偏差は \\(\\sqrt{1.05} \\approx 1.02\\) である（「\\(\\approx\\)」は「ほぼ等しい」という意味）。最小値は0、最大値は5である。 この分布は、次の図のような形をしている。\n\n\n\n\n\nsample() を使わずに、Rでコイン投げを実行してみよう。Rで二項分布に従う乱数を生成する関数は、rbinom() である。この関数で指定しなければならない引数（ひきすう）は以下の3つである。\n\n\nn：実験の回数\n\nsize: 試行回数（0以上の（非負の）整数）\n\nprob: 成功確率（コイン投げで表が出る確率。0以上1以下）\n\nたとえば、rbinom(n = 8, size = 10, prob = 0.4 ) とすると、「表が出る確率が0.4のコインを10回投げる」という実験を8回実行する。\n\nrbinom(n = 8, size = 10, prob = 0.4)\n\n[1] 5 4 5 6 2 2 3 2\n\n\n結果として、8つの数字が表示されるが、それぞれの数字が、1回ごとの実験（コインを10回投げる）で表が何回出たかを表している。\n\n\n\n\n\n\nWarning\n\n\n\nこの数は乱数 (random numbers)、つまり、Rによってランダムに生み出された数字なので、人によって異なる数字が得られるはずで、このWebページと同じ数字が出るとは限らない。\n\n\n試しにまったく同じ関数をもう一度実行すると、違う数が得られる。\n\nrbinom(n = 8, size = 10, prob = 0.4)\n\n[1] 3 3 4 4 4 3 6 3\n\n\n表が出る確率が0.5のコインを使って、1回のコイン投げ実験を1回だけ実行するには、\n\nrbinom(n = 1, size = 1, prob = 0.5)\n\n[1] 0\n\n\nとする。0と出れば表が0回出た（つまり、裏が出た）ということであり、1ならば表が出たということである。何度か試してみよう。\n\nrbinom(n = 1, size = 1, prob = 0.5)\n\n[1] 1\n\n\n\nrbinom(n = 1, size = 1, prob = 0.5)\n\n[1] 0\n\n\n\nrbinom(n = 1, size = 1, prob = 0.5)\n\n[1] 1\n\n\n\nrbinom(n = 1, size = 1, prob = 0.5)\n\n[1] 0\n\n\n\nrbinom(n = 1, size = 1, prob = 0.5)\n\n[1] 0\n\n\n表が出る確率が0.5のコインを使って、1回のコイン投げ実験を10回まとめて実行するには、次のようにする。\n\nrbinom(n = 10, size = 1, prob = 0.5)\n\n [1] 0 0 0 1 0 1 1 0 1 0\n\n\n実習課題 (2)\n\n3つの引数の値を変えて、様々な条件で二項分布からの乱数生成を試してみよう！\n\n\n\n3.3.3 正規分布\n正規分布 (normal distribution) からの乱数生成には、rnorm() を使う。この関数では、以下の3つの引数（ひきすう）を指定する。\n\n\nn: 生成する乱数の個数（必ず指定する）\n\nmean: 正規分布の平均値（指定しないと 0 に設定される）\n\nsd: 正規分布の標準偏差（指定しないと 1 に設定される）\n\n平均と標準偏差を指定しないと、平均が0で標準偏差が1の正規分布、すなわち標準正規分布からの乱数生成が行われる。\n標準正規分布から100個の乱数を生成してみよう。\n\nb1 &lt;- rnorm(n = 100)\n\n作った乱数をヒストグラムにしてみよう。\n\ndf_n1 &lt;- tibble(b1)\nh_n1 &lt;- ggplot(df_n1, aes(x = b1)) +\n  geom_histogram(color = \"black\", fill = \"dodgerblue\") +\n  labs(x = \"標準正規分布からの乱数\", y = \"度数\")\nplot(h_n1)\n\n\n\n\n正規分布に見えるだろうか？ 乱数の平均値と標準偏差を計算してみよう。\n\nmean(b1)\n\n[1] 0.05545118\n\nsd(b1)\n\n[1] 0.9989977\n\n\n元の分布の平均値と標準偏差と比べると、どんなことが言えるだろうか？\n乱数の数を増やして同じことしてみよう。\n\nb2 &lt;- rnorm(n = 10000)\ndf_n2 &lt;- tibble(b2)\nh_n2 &lt;- ggplot(df_n2, aes(x = b2)) +\n  geom_histogram(color = \"black\", fill = \"dodgerblue\") +\n  labs(x = \"標準正規分布からの乱数\", y = \"度数\")\nplot(h_n2)\n\n\n\n\n今度はどうだろうか？\n乱数の平均値と標準偏差を計算してみよう。\n\nmean(b2)\n\n[1] 0.00484611\n\nsd(b2)\n\n[1] 0.9888682\n\n\n元の分布の平均値と標準偏差と比べると、どんなことが言えるだろうか？\n実習課題 (3)\n\n平均が10, 標準偏差が4の正規分布から乱数を1,000個生成し、結果をヒストグラムにしてみよう。また、乱数の平均値と標準偏差を計算し、元になった分布と比べてみよう。"
  },
  {
    "objectID": "clt.html#sec-prep8",
    "href": "clt.html#sec-prep8",
    "title": "\n4  中心極限定理\n",
    "section": "\n4.1 準備",
    "text": "4.1 準備\n必要なパッケージを読み込む。\n\nlibrary(tidyverse)\n\n## 図のなかで日本語を使えるようにする\n## フォントの設定はお好みで\n## （Unix/Linux ではIPAexフォントのインストールが必要かも）\nif (.Platform$OS.type == \"windows\") { # Windows\n  library(fontregisterer)\n  my_font &lt;- \"Yu Gothic\"\n} else if (capabilities(\"aqua\")) { # macOS\n  my_font &lt;- \"HiraginoSans-W3\"\n} else { # Unix/Linux\n  my_font &lt;- \"IPAexGothic\"\n}\ntheme_set(theme_gray(base_size = 9,\n                     base_family = my_font))"
  },
  {
    "objectID": "clt.html#sec-clt",
    "href": "clt.html#sec-clt",
    "title": "\n4  中心極限定理\n",
    "section": "\n4.2 中心極限定理",
    "text": "4.2 中心極限定理\n中心極限定理 (Central Limit Theorem)　は、「標本サイズ（サンプルサイズ）が大きくなれば、標本平均は正規分布で近似できる」という定理である（より正確には、「標本サイズを無限大にすると標本平均を標準化したものが標準正規分布に収束する」という定理である）。厳密に理解する（証明する）のはこの授業の範囲を超える（つまり、難しい）。しかし、私たちが統計的推定や検定を行うときに正規分布（特に標準正規分布）ばかり使ってもいいのは、この定理のおかげである。したがって、実際に正規分布ではない分布から正規分布ができるということを理解する必要がある。\nそこで、Rでシミュレーションを実行することを通じて中心極限定理を理解しよう。\n例として、10個のボールが入った袋を考える。ボールにはそれぞれ0から9までの整数が書いてあるとする。この袋から、ランダムに1つボールを選ぶとすると、選んだボールに書かれた数は、0から9までの整数のどれかで、0から9が選ばれる確率は等しく10分の1（0.1）である。図にすると、以下のようになる。\n\n\n\n\n\nつまり、ランダムにボールを1つ選ぶというのは、（離散）一様分布からの乱数生成である。 1つボールを選ぶとき、ボールに書かれている数の平均値（期待値）は、\\((9 - 0) / 2 = 4.5\\) である。\nここで、私たちはボールにどんな数が書かれているか知らない（0から9ではなく、100から109かもしれないし、すべての数が奇数かもしれない）と仮定しよう。この状態で、この袋からボールを引く作業を繰り返し（復元抽出する）、ボールに書かれている数の平均値を当てたい（正解は4.5）。\nもっとも単純な方法は、ボールを \\(n\\) 回引いて、その平均値を使うという方法である。\nまず、ボールを2回だけ引いて平均値を当てるという実験を行ってみよう。この実験をすると、1回目のボールの選び方は10通り、2回目のボールの選び方も10通りあるので、全部で100通りの選び方がある。しかし、2つのボールに書かれている数は0から9までの整数なので、可能な合計値は0から18までの19通りであり、平均値は「合計/2」 なので、平均値も19通りしかない。\n理論的には、次の図のような確率で、それぞれの平均値が得られる。\n\n\n\n\n\nこの図から、この実験を1回だけ行うとき、正解である4.5が選ばれる確率は0.1 であることがわかる。試しに1回やってみよう。\n\nbag &lt;- 0:9  # 袋の中身を定義する\nexp_2 &lt;- sample(bag, size = 2, replace = TRUE)  # 復元抽出\nmean(exp_2)   # 平均値を求める\n\n[1] 7.5\n\n\n今回は、たまたま7.5になった。\nでは、この実験を1,000回繰り返すと「それぞれの回での平均値の分布」はどんな形になるだろうか。実際にやってみよう。\nRで同じ作業を繰り返し行う簡単な方法は、for ループを使うことである。for の直後の丸カッコで繰り返し回数を指定し、ループさせる内容を中括弧 { } で囲む。 たとえば、0からスタートして「1を足す」という作業を5回繰り返すには、次のようにする。\nまず、スタート時の数である0を保存する。\n\na &lt;- 0  # a に0を入れる\n\n次に、結果を保存するために、result という名前の入れ物を用意する。NA は「空」の状態を表す（これを欠測値 [missing value] と呼ぶ）。また、 length.out で保存場所が何個分必要か指定する。\n\nresult &lt;- rep(NA, length.out = 5) \n\nこの時点で result の中身を確認してみよう。\n\nresult  # result の中身を確認する\n\n[1] NA NA NA NA NA\n\n\nすべて NA になっている。\nforループを利用して、数を1だけ加える作業を5回繰り返す。\n\nfor (i in 1 : 5) {    # i が1から5までの繰り返し\n  a &lt;- a + 1        # a に1を足す\n  result[i] &lt;- a    # i番目の足し算の結果を result[i] に入れる    \n}\nresult  # resultの中身を確認\n\n[1] 1 2 3 4 5\n\n\nこのループを利用して、ボールを2回引く作業を1,000回繰り返してみよう。\n\nN &lt;- 2                                # 標本サイズ\ntrials &lt;- 1000                        # 実験の繰り返し回数\nsim1 &lt;- rep(NA, length.out = trials)  # 結果の保存容器\nfor (i in 1 : trials) {\n  experiment &lt;- sample(bag, size = N, replace = TRUE)  # 復元抽出\n  sim1[i] &lt;- mean(experiment)         # i 回目の平均値を保存\n}\n\n結果をヒストグラムにしてみよう。\n\ndf_sim1 &lt;- tibble(avg = sim1)\nh_sim1 &lt;- ggplot(df_sim1, aes(x = avg)) +\n  geom_histogram(binwidth = 1, \n                 boundary = 0.5,\n                 color = \"black\") +\n  labs(x = \"2個のボールの平均値\", \n       y = \"度数\") +\n  scale_x_continuous(breaks = 0 : 9)\nplot(h_sim1)\n\n\n\n\nこの分布は正規分布に見えるだろうか？\n次に、サンプルサイズ \\(N\\) を2から5に増やし、同様の実験をしてみよう。\n\nN &lt;- 5                                # サンプルサイズ\ntrials &lt;- 1000                        # 実験の繰り返し回数\nsim2 &lt;- rep(NA, length.out = trials)  # 結果の保存容器\nfor (i in 1:trials) {\n  experiment &lt;- sample(bag, size = N, replace = TRUE)  # 復元抽出\n  sim2[i] &lt;- mean(experiment)         # i 回目の平均値を保存\n}\n\n結果をヒストグラムにしてみよう。\n\ndf_sim2 &lt;- tibble(avg = sim2)\nh_sim2 &lt;- ggplot(df_sim2, aes(x = avg)) +\n  geom_histogram(binwidth = 0.5, \n                 boundary = 0.5,\n                 color = \"black\") +\n  labs(x = \"5個のボールの平均値\", \n       y = \"度数\") +\n  scale_x_continuous(breaks = 0:9)\nplot(h_sim2)\n\n\n\n\nこの分布は正規分布に見えるだろうか？\nサンプルサイズ \\(N\\) を10に増やしてみよう。\n\nN &lt;- 10                              # サンプルサイズ\ntrials &lt;- 1000                       # 実験の繰り返し回数\nsim3 &lt;- rep(NA, length.out = trials) # 結果の保存容器\nfor (i in 1 : trials) {\n  experiment &lt;- sample(bag, size = N, replace = TRUE)  # 復元抽出\n  sim3[i] &lt;- mean(experiment)        # i 回目の平均値を保存\n}\n\n結果をヒストグラムにしてみよう。\n\ndf_sim3 &lt;- tibble(avg = sim3)\nh_sim3 &lt;- ggplot(df_sim3, aes(x = avg)) +\n  geom_histogram(binwidth = 0.5,\n                 color = \"black\") +\n  labs(x = \"10個のボールの平均値\", y = \"度数\")\nplot(h_sim3)\n\n\n\n\nこの分布は正規分布に見えるだろうか？\nサンプルサイズ \\(N\\) を100に増やしてみよう。\n\nN &lt;- 100                             # サンプルサイズ\ntrials &lt;- 1000                       # 実験の繰り返し回数\nsim4 &lt;- rep(NA, length.out = trials) # 結果の保存容器\nfor (i in 1 : trials) {\n  experiment &lt;- sample(bag, size = N, replace = TRUE)  # 復元抽出\n  sim4[i] &lt;- mean(experiment)        # i 回目の平均値を保存\n}\n\n結果をヒストグラムにしてみよう。\n\ndf_sim4 &lt;- tibble(avg = sim4)\nh_sim4 &lt;- ggplot(df_sim4, aes(x = avg)) +\n  geom_histogram(binwidth = 0.125, \n                 color = \"black\") +\n  labs(x = \"100個のボールの平均値\", y = \"度数\")\nplot(h_sim4)\n\n\n\n\nこのように、元の分布は一様分布でも、サンプルサイズ \\(N\\) を増やすと、「平均値の分布」は正規分布に近づく。よって、サンプルサイズ \\(N\\) が十分大きい（大まかな目安は \\(N &gt; 100\\)）とき、正規分布を使って統計的推定や検定を行うことが許される。\n実習課題\n\n\n\\(N=5\\) と \\(N=500\\) のそれぞれの場合について、同様の実験を行ってみよう。"
  },
  {
    "objectID": "intro-to-inference.html#sec-prep9",
    "href": "intro-to-inference.html#sec-prep9",
    "title": "\n5  統計的推定と仮説検定の基礎\n",
    "section": "\n5.1 パッケージの読み込み",
    "text": "5.1 パッケージの読み込み\n今回利用するパッケージを読み込む。\n\nlibrary(tidyverse)\n\n次に、図の中で日本語が正しく表示されるようにする。\n\n## 図のなかで日本語を使えるようにする\n## フォントの設定はお好みで\n## （Unix/Linux ではIPAexフォントのインストールが必要かも）\nif (.Platform$OS.type == \"windows\") { # Windows\n  library(fontregisterer)\n  my_font &lt;- \"Yu Gothic\"\n} else if (capabilities(\"aqua\")) { # macOS\n  my_font &lt;- \"HiraginoSans-W3\"\n} else { # Unix/Linux\n  my_font &lt;- \"IPAexGothic\"\n}\ntheme_set(theme_gray(base_size = 9,\n                     base_family = my_font))"
  },
  {
    "objectID": "intro-to-inference.html#sec-example9",
    "href": "intro-to-inference.html#sec-example9",
    "title": "\n5  統計的推定と仮説検定の基礎\n",
    "section": "\n5.2 例題",
    "text": "5.2 例題\n問題： 表が出る確率が0.5のコインを \\(N\\)回投げたところ、10回表が出た。コインを投げた回数\\(N\\)はいくつ？\n\n私たちが観察したこと（データ）：「表が10回」\n私たちが知りたい数（母数, パラメタ, parameter）：\\(N\\)\n\n\n\n\n\n\n\n\nNote\n\n\n\nこの例題は、小島寛之 (2006)『完全独習 統計学入門』（ダイヤモンド社）の第9講からとった。詳細な解説については小島 (2006: 90-106) を参照されたい。"
  },
  {
    "objectID": "intro-to-inference.html#sec-refbinom",
    "href": "intro-to-inference.html#sec-refbinom",
    "title": "\n5  統計的推定と仮説検定の基礎\n",
    "section": "\n5.3 準備：二項分布（復習）",
    "text": "5.3 準備：二項分布（復習）\n前のトピックで学習したとおり、コイン投げの結果は二項分布を利用して考えることができる。\nたとえば、「表が出る確率が0.45のコインを10回投げる」という実験を7回実行するには次のようにする。\n\nrbinom(n = 7, size = 10, prob = 0.45)\n\n[1] 2 3 4 5 4 3 4"
  },
  {
    "objectID": "intro-to-inference.html#sec-test",
    "href": "intro-to-inference.html#sec-test",
    "title": "\n5  統計的推定と仮説検定の基礎\n",
    "section": "\n5.4 統計的仮説検定の基礎",
    "text": "5.4 統計的仮説検定の基礎\n上で出された例題について、以下の2つの仮説を考えよう。\n\n\n仮説 1： \\(N＝16\\)\n\n\n仮説 2： \\(N＝36\\)\n\n\n\n5.4.1 仮説1 (\\(N=16\\)) が正しいと仮定する\n仮説1が正しいとすると、1回のコイン投げ実験はrbinom(n = 1, size = 16, prob = 0.5) で表されるはずである（問題で設定した\\(N\\)は、rbinom()関数では size である。nではないので注意！）。例題では、たまたま10回表が出たということになる。 試してみよう。\n\nrbinom(n = 1, size = 16, prob = 0.5)\n\n[1] 10\n\n\n表は何回出ただろうか？\nもう1度試してみよう。\n\nrbinom(n = 1, size = 16, prob = 0.5)\n\n[1] 10\n\n\n表は何回出ただろうか？\n1回ずつ結果を出すと面倒なので、まとめて10,000回この実験を実施し、結果をresult1という名前で保存してみよう。\n\nresult1 &lt;- rbinom(n = 10000, size = 16, prob = 0.5)\n\n上の関数をRStudio で実行すると、右下（あるいは右上）の “Environment” タブの “Values” という列に result1が表示されるはずである。そして、その横に int [1:10000] と書かれているはずである。これは、result1の中身を示しており、int というのは整数 (integer) のことで、[1:10000] というのは、1個目から10,000個目まで数がある（つまり、「A : B」は「AからBまでの整数」という意味）ことを示している。「コインを16回投げる」という実験を実際に10,000回繰り返し、その結果を手で書いて記録するのはものすごく大変だが、Rを使えば同様の実験をほんの数秒で実施できてしまう。\nこの結果を詳しく検討して見よう。まず、表が出る回数の平均値 (mean) はいくつだろうか。\n\nmean(result1)\n\n[1] 8.0199\n\n\n平均すると 8.0199回表が出たことがわかった。理論値である \\(16 \\cdot 0.5 = 8\\) に近い値である。\n分散 (variance) と標準偏差 (standard deviation) はいくつだろうか。\n\nvar(result1)\n\n[1] 3.992303\n\nsd(result1)\n\n[1] 1.998075\n\n\n分散の理論値は \\(16\\cdot 0.5 (1 - 0.5) = 4\\)、標準偏差の理論値は\\(\\sqrt{4} = 2\\) だから、どちらもほぼ理論値どおりの値である。\nこの実験結果をヒストグラムにしてみよう。 縦軸を確率密度 (probability density) にするために、y = after_stat(density) を指定する。\n\ndf1 &lt;- tibble(x = result1)\nhist1 &lt;- ggplot(df1, aes(x = x, y = after_stat(density))) +\n  geom_histogram(color = \"black\", \n                 fill = \"skyblue\",\n                 binwidth = 1) +\n  labs(x = \"表が出た回数\", \n       y = \"確率密度\",\n       title = \"表が出る確率0.5のコインを16回投げる\")\nplot(hist1)\n\n\n\n\n例題で得られた「表が10回」という結果は、このヒストグラムのどの辺りにあるだろうか。これをgeom_vline()で加えてみよう。\n\nhist2 &lt;- hist1 + \n    geom_vline(xintercept = 10, \n               color = \"tomato\")\nplot(hist2)\n\n\n\n\nこのヒストグラムの形状に注目してみると、なんとなく正規分布に似ているように見える。そこで、先ほど計算した平均値と標準偏差（分散）を利用して、平均が 8.0199で標準偏差が1.9980749の正規分布を、このヒストグラムに重ねて描いてみよう。\n\n# 次の2行の中身は現時点で理解しなくてもよい\ndf2 &lt;- tibble(x = seq(from = 0, to = 16, length.out = 1000)) |&gt; \n  mutate(y = dnorm(x, mean = mean(result1), sd = sd(result1)))\nhist3 &lt;- hist2 + geom_line(data = df2, aes(x = x, y = y), color = \"darkblue\")\nplot(hist3)\n\n\n\n\nこの図からわかるとおり、二項分布から得られたヒストグラムの形は、正規分布によく似ている（こういう状況を、「正規分布で近似できる」という）。\n私たちが実験で手に入れたデータ (result1) のヒストグラムが正規分布に似ていることがわかったので、正規分布の特徴を（統計学1の内容から）思い出して使ってみよう。正規分布の特徴から、平均\\(\\pm\\) 2標準偏差の間にデータの約95%があるはずである。 したがって、仮説1 (\\(N=16\\)) が正しいとすれば、表が出る回数の95%は、\n\nmean(result1) - 2 * sd(result1)\n\n[1] 4.02375\n\n\nと\n\nmean(result1) + 2 * sd(result1)\n\n[1] 12.01605\n\n\nの間にあるはずだ。\n念のため、正規分布に頼らずに私たの実験結果からも同じことを確かめてみよう。私たちは実験を10,000回繰り返した。実験の結果として得られた10,000個の数を、小さい順に並べ替えてみよう。小さい順の並べ替えは、sort()で行う。\n\nresult1_sorted &lt;- sort(result1)\n\nこの並べ替えたデータのうち、小さい方から2.5%（つまり１番小さい数から250番目に小さい数まで）と大きい方から2.5%（つまり、9751番目に小さい数から10,000番目に小さい数、言い換えると、１番大きい数から250番目に大きい数）を取り除くと、平均に近い95%のデータを残すことができる。つまり、10,000回の実験結果を小さい順に並べ替えたとき、251番目から9750番目までの数が、平均周りの95%になる。\nRで単純な数の集まり（ベクトル, ヴェクタ [vector] と呼ぶ）から特定の位置にあるものを抜き出すときは[] を使う。Aという変数の3番目の要素を取り出したいときはA[3]と書き、5番目から8番目までを取り出したいときは、A[5:8] と書く。\n私たちが知りたいのは、result1_sorted（実験結果を小さい順に並べ替えたもの）の251番目と9750番目である。\n\nresult1_sorted[251]\n\n[1] 4\n\nresult1_sorted[9750]\n\n[1] 12\n\n\nつまり、データの95%は、4 と12 の間にある。これは正規分布を利用して求めた数と（ほぼ）同じである。\n小さい順に並べ替えた後、特定のパーセンテージの位置にある数は、Rのquantile() を使えば、もっと簡単に求められる。私たちが知りたいのは、下から2.5% (0.025) と97.5% (0.975) の位置なので、次のようにする。\n\nquantile(result1, prob = 0.025)\n\n2.5% \n   4 \n\nquantile(result1, prob = 0.975)\n\n97.5% \n   12 \n\n#quantile(result1, prob = c(0.025, 0.975))  # 2つの値を1度に求めたいとき\n\nこのように、わざわざ小さい順に並べ替えたり2.5%と97.5%は何番目の数かを考えたりしなくても、quantile() を使えば簡単に答えが求められる。\nいずれの方法を使っても、仮にコイン投げの回数が16回（仮説1）だとすれば、例題の観測値として得られた「10回」という回数は、平均周りの95%の範囲に含まれている。つまり、「16回コインを投げて10回表が出る」という現象は、特に珍しいわけではない。よって、\\(N=16\\)という仮説を否定するような証拠はないと考えられる。仮説1はとりあえず保留しておこう。\n\n5.4.2 仮説2 (\\(N=36\\)) が正しいと仮定する\n仮説2が正しいとすると、1回のコイン投げ実験はrbinom(n = 1, size = 36, prob = 0.5) で表されるはずである。例題では、たまたま10回表が出たということになる。 試してみよう。\n\nrbinom(n = 1, size = 36, prob = 0.5)\n\n[1] 15\n\n\n表は何回出ただろうか？\nもう1度試してみよう。\n\nrbinom(n = 1, size = 36, prob = 0.5)\n\n[1] 20\n\n\n表は何回出ただろうか？\n先ほどと同様にこの実験をまとめて10,000回実施し、結果をresult2という名前で保存してみよう。\n\nresult2 &lt;- rbinom(n = 10000, size = 36, prob = 0.5)\n\nこの結果を詳しく検討してみよう。 まず、表が出る回数の平均値はいくつだろうか。\n\nmean(result2)\n\n[1] 18.0633\n\n\n平均すると 18.0633回表が出たことがわかった。\n分散と標準偏差はいくつだろうか。\n\nvar(result2)\n\n[1] 8.992192\n\nsd(result2)\n\n[1] 2.998698\n\n\n結果をヒストグラムにしてみよう。\n\ndf3 &lt;- tibble(x = result2)\nhist4 &lt;- ggplot(df3, aes(x = x, y = after_stat(density))) +\n  geom_histogram(color = \"black\", \n                 fill = \"skyblue\", \n                 binwidth = 1) +\n  labs(x = \"表が出た回数\", \n       y = \"確率密度\",\n       title = \"表が出る確率0.5のコインを36回投げる\") +\n  geom_vline(xintercept = 10, \n             color = \"tomato\")\nplot(hist4)\n\n\n\n\n例題で得られた「表が10回」という結果は、このヒストグラムのどの辺りにあるだろうか。\nこのヒストグラムの形状に注目してみると、なんとなく正規分布に似ているように見える。そこで、先ほど計算して平均値と標準偏差（分散）を利用して、平均が 18.0633で標準偏差が2.9986984の正規分布を、このヒストグラムに重ねて描いてみよう。\n\n# 次の2行の中身は現時点で理解しなくてもよい\ndf4 &lt;- tibble(x = seq(from = 0, to = 32, length.out = 1000)) |&gt;\n  mutate(y = dnorm(x, mean = mean(result2), sd = sd(result2)))\nhist5 &lt;- hist4 + geom_line(data = df4, aes(x = x, y = y), color = \"darkblue\")\nplot(hist5)\n\n\n\n\n先ほどと同様、二項分布から得られたヒストグラムは正規分布によく似ている。\n私たちが実験で手に入れたデータ (result2) のヒストグラムが正規分布に似ていることがわかったので、正規分布の特徴から平均\\(\\pm\\) 2標準偏差の間にデータの約95%があるはずである。 したがって、仮説2 (\\(N=36\\)) が正しいとすれば、表が出る回数の95%は、\n\nmean(result2) - 2 * sd(result2)\n\n[1] 12.0659\n\n\nと\n\nmean(result2) + 2 * sd(result2)\n\n[1] 24.0607\n\n\nの間にあるはずだ。\n念のため、正規分布に頼らずに私たの実験結果からも同じことを確かめてみると\n\nquantile(result2, prob = 0.025)\n\n2.5% \n  12 \n\nquantile(result2, prob = 0.975)\n\n97.5% \n   24 \n\n#quantile(result2, prob = c(0.025, 0.975))  # 1行で求めたいとき\n\nとなり、（ほぼ）同じ結果が得られる。\nいずれの方法を使っても、仮にコイン投げの回数が36回（仮説2）だとすれば、例題の観測値として得られた「10回」という回数は、平均周りの95%の範囲に含まれていない。つまり、「36回コインを投げて10回表が出る」という現象は、とても珍しい現象であり、あまり起こることは期待されない。これは、\\(N=36\\)という仮説を否定するような証拠と考えられるので、\\(N=36\\)という仮説は棄却 (reject) する。"
  },
  {
    "objectID": "intro-to-inference.html#sec-estimation",
    "href": "intro-to-inference.html#sec-estimation",
    "title": "\n5  統計的推定と仮説検定の基礎\n",
    "section": "\n5.5 統計的推定の基礎",
    "text": "5.5 統計的推定の基礎\n仮説検定の方法を使えば、1つひとつの仮説について、その説がおかしいと言える証拠があるかどうか確かめることができる。しかし、理論的に可能な仮説はたくさん存在しており、1つひとつ確かめるのは少し面倒だ。私たちが考えている例題の場合、10以上の整数であれば、どんな数でも可能である（\\(N=36\\) が仮説として妥当でないとわかった時点で、37以上の数は無視できるが）。\nそこで、そもそも \\(N\\) はいくつなのかということ自体を直接考えるのが、統計的推定 (statistical estimation) である。\n\n5.5.1 点推定 (point estimation)\nある特定の分布で、もっとも起こりそうな結果は何だろうか？\n例として、「試行回数5で、成功確率0.4の二項分布」を考えよう。 この分布は以下のような形をしている。\n\n\n\n\n\nこの図をみて、どんな結果がもっとも起こりやすそうだと考えられるだろうか。図からは、成功回数2回がもっとも起こりやすそうだということがわかる。 また、この分布の平均値は、\\(5 \\cdot 0.4 = 2\\) である。\nこれらの知識を利用すると、二項分布では平均値がもっとも起こりやすそうである（自習課題：他の値をパラメタ（母数）にもつ二項分布でもそう言えるか自分で確かめよ）。\nこの知識を利用して私たちの例題について考えてみよう。 私たちは試行回数 \\(N\\) を知りたいが、どんな試行回数であっても、もっとも起こりやすいのは平均値だとする。そうすると、10回表が出たということから、平均値が10になるような二項分布を探せばよいことになる。成功確率は0.5だとわかっているので、この関係を式にすると、 \\[\nN \\cdot 0.5 = 10\n\\] となる。この式を解くと、 \\(N = 20\\) となる。つまり、「試行回数20で成功確率の0.5の二項分布の平均値が10である」ということがわかる。この平均値が私たちのデータに合致するので、私たちは、「\\(N=20\\)」 という推定を行う。このようにして得られた、1つの数をピンポイントで示す推定法を点推定 (point estimation) と呼び、得られた値（20）を点推定値 (point estimate) と呼ぶ。\n私たちの例題の点推定値は20である。\n\n5.5.2 区間推定 (interval estimation)\n上で1つの値を推定したが、私たちが推定を行うとき、その推定にどれくらい自信があるか（より正確には、どれくらい自信がないか）は問題によって違う。推定値が同じ10でも、「絶対10だ」というのと「だいたい10くらいだろう」というのでは、答えの意味は異なる。そこで、この「推定に対する自信のなさ (uncertainty)」を推定の方法に取り込んだのが、区間推定 (interval estimation) と呼ばれる方法である。\nより具体的には、統計的仮説検定で棄却されない仮説の集合を、区間推定に使う。私たちは、\\(N=36\\)という仮説（仮説2）を棄却した。したがって、\\(N=36\\) は区間推定には使わない。他方、\\(N=16\\) という仮説は棄却しなかった（保留した）ので、\\(N=16\\) は区間推定の一部として使う。\\(N=36\\) が仮説として妥当でないことがわかっているので、\\(N=10, 11, \\dots, 35\\) について、仮説が棄却できるかどうか確かめればよい。\nしかし、上の仮説検定で実行したことを何度も何度も繰り返すのは、やや面倒である。そこで、実験のための関数を自分で作ってしまおう。関数の作り方はまだ理解しなくてもいいので、こんなことができるということを体験して欲しい。Rで自分の関数を作るには、function() を使う（つまり、「関数」という名前の関数で新たな関数を作る）。\n\nbin_exp &lt;- function(h, trials = 10000) {\n  # h: 仮説 (hypothesis) N = h を検証する\n  # trials: 実験の繰り返し回数、既定（デフォルト）値は10,000\n  res &lt;- rbinom(n = trials, size = h, prob = 0.5)\n  return(quantile(res, prob = c(0.025, 0.975)))\n}\n\n上のコマンドは関数を定義しただけなので、実行しても何も起きない。ただし、RStudio では右下（または右上）の “Environment” タブの中に、“Functions（関数）” という項目が追加され、そこに定義した bin_exp が表示されているはずである。\nこの関数を使ってみよう。先ほど試した仮説1 (\\(N=16\\)) を検証するには、次のようにする。\n\nbin_exp(16)\n\n 2.5% 97.5% \n    4    12 \n\n\n先ほどと（ほぼ）同じ結果が得られた。データである10はこの2つの数値の間にあるので、仮説1は保留する。\n実験の繰り返し回数を変更し、5000回にすると、\n\nbin_exp(16, trials = 5000)\n\n 2.5% 97.5% \n    4    12 \n\n\nとなる。\n同様に、仮説2 (\\(N=36\\)) は、\n\nbin_exp(36)\n\n 2.5% 97.5% \n   12    24 \n\n\nとなり、データである10はこの2つの数値の間にはないので、仮説2を棄却する。\nこの関数を使えば比較的簡単に10以上、35以下のすべての数について仮説を棄却すべきかどうか確かめられる。1つ1つの値を順番に検証してもいいが、一気に実行するには次のようにする。\n\nset.seed(2019-05-10)  # 乱数の種を指定\nx &lt;- 10:35          # 10から35までの整数の数列を作り、xという名前で保存する\nnames(x) &lt;- 10:35\nsapply(x, bin_exp)    # xの要素をすべて bin_exp に適用 (apply) する\n\n      10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33\n2.5%   2  2  3  3  3  4  4  5  5  5  6  6  6  7  7  8  8  9  9  9 10 10 11 11\n97.5%  8  9  9 10 11 11 12 12 13 14 14 15 15 16 17 17 18 19 19 20 20 21 21 22\n      34 35\n2.5%  11 12\n97.5% 23 23\n\n\nsapply() の意味を理解するのが難しければ、for ループを使ってもよい。\n\nset.seed(2019-05-10)     # 乱数の種を指定\nfor (x in 10:35) {\n  res &lt;- bin_exp(x)\n  cat(x, \":\", res, \"\\n\") # 結果を表示するためのコード\n}\n\n10 : 2 8 \n11 : 2 9 \n12 : 3 9 \n13 : 3 10 \n14 : 3 11 \n15 : 4 11 \n16 : 4 12 \n17 : 5 12 \n18 : 5 13 \n19 : 5 14 \n20 : 6 14 \n21 : 6 15 \n22 : 6 15 \n23 : 7 16 \n24 : 7 17 \n25 : 8 17 \n26 : 8 18 \n27 : 9 19 \n28 : 9 19 \n29 : 9 20 \n30 : 10 20 \n31 : 10 21 \n32 : 11 21 \n33 : 11 22 \n34 : 11 23 \n35 : 12 23 \n\n\n\\(N\\)が10から12の間または32以上では、データである10が2つの数値の間にないことがわかるので、これらの仮説は棄却する。よって、「\\(N \\in [13, 31]\\) すなわち \\(13 \\leq N \\leq 31\\) （\\(N\\)は整数）」と答えるのが、区間推定である。"
  },
  {
    "objectID": "pop-n-sample.html#sec-prep10",
    "href": "pop-n-sample.html#sec-prep10",
    "title": "\n6  母集団と標本をシミュレーションで理解する\n",
    "section": "\n6.1 準備",
    "text": "6.1 準備\n必要なパッケージを読み込む。\n\nlibrary(tidyverse)\n\n## 図のなかで日本語を使えるようにする\n## フォントの設定はお好みで\n## （Unix/Linux ではIPAexフォントのインストールが必要かも）\nif (.Platform$OS.type == \"windows\") { # Windows\n  library(fontregisterer)\n  my_font &lt;- \"Yu Gothic\"\n} else if (capabilities(\"aqua\")) { # macOS\n  my_font &lt;- \"HiraginoSans-W3\"\n} else { # Unix/Linux\n  my_font &lt;- \"IPAexGothic\"\n}\ntheme_set(theme_gray(base_size = 9,\n                     base_family = my_font))"
  },
  {
    "objectID": "pop-n-sample.html#sec-simpopnsample",
    "href": "pop-n-sample.html#sec-simpopnsample",
    "title": "\n6  母集団と標本をシミュレーションで理解する\n",
    "section": "\n6.2 母集団と標本のシミュレーション",
    "text": "6.2 母集団と標本のシミュレーション\n\n6.2.1 母集団を用意する\n例として、女性4,600人、男性5,400人から成る母集団を考える。合計10,000人で、女性比率が0.46、男性比率は0.54である。これらは母集団の比率なので、母比率と呼ばれる。\nこの母集団 (population) をRで定義しよう。\n\npop &lt;- rep(c(\"female\", \"male\"), c(4600, 5400))\n\n総人口を確認する。\n\nlength(pop)\n\n[1] 10000\n\n\n男女の数を確認する。\n\ntable(pop)\n\npop\nfemale   male \n  4600   5400 \n\n\n例題どおりの母集団が定義できた。\nここで、私たちは母比率を知らないと仮定しよう。 正しい母比率を調べるもっとも単純な方法は、1万人全員の性別を調べることである。しかし、1万人を調査するのは大変なので、1万人から100人だけを無作為に（ランダムに）選び、100人の性別を調べ、その結果を利用して母比率を推定することにする。\n\n6.2.2 母集団から100人をランダムに選ぶ\n上で定義した母集団から、ランダムに100人を抜き出してみよう。\nsample() でランダムに100人抽出すればよい。同じ人物を2度以上抜き出すことがないよう、replace = FALSE で非復元抽出を指定する。また、標本サイズ \\(N\\) は繰り返し使うので、最初に定義しておく。\n\nN &lt;- 100\nsample_1 &lt;- sample(pop, size = N, replace = FALSE)\n\n取り出した\\(N=100\\)のサンプルで、男女の比率を調べてみよう。\n\ntable(sample_1) / N\n\nsample_1\nfemale   male \n  0.51   0.49 \n\n\nこの比率は標本（サンプル）の比率なので、標本比率と呼ばれる。 女性比率だけを調べる（女性比率がわかれば男性比率もわかるので）には、\n\nsum(sample_1 == \"female\") / N\n\n[1] 0.51\n\n\nまたは、\n\nmean(sample_1 == \"female\")\n\n[1] 0.51\n\n\nとすればよい。\nもう一度、別の100人で調べてみよう（先ほどと同じ人物が選ばれる可能性はある）。\n\nsample_2 &lt;- sample(pop, size = N, replace = FALSE)\nmean(sample_2 == \"female\")\n\n[1] 0.44\n\n\nもう一度、別の100人で調べてみよう（先ほどと同じ人物が選ばれる可能性はある）。\n\nsample_3 &lt;- sample(pop, size = N, replace = FALSE)\nmean(sample_3 == \"female\")\n\n[1] 0.4\n\n\nこのように、毎回異なる標本が抽出され、その結果として異なる標本比率が得られる。標本から得られる統計量は、母数（この例題の場合は母比率）と必ずしも一致しないし、同じ方法を何度も繰り返すと異なる値が得られる。\n1万人から100人を選ぶ方法は \\(6.5 \\times 10^{241}\\) 通りあるので、全部の組み合わせを調べるのは不可能である。そこで、Rを使って10,000通りだけ調べてみよう。\nまず、1万個の結果（女性の標本比率）を保存する容器（ベクトル, vector）を用意する。\n\nres_1 &lt;- rep(NA, 1e4) \n\nNA は欠測値（値がないこと）を表す。まだ結果を得ていないので、欠測値が1万個ある「空の」容器を用意した。\n\n\n\n\n\n\nTip\n\n\n\n1e4 というのは、\\(1 \\times 10^4\\) すなわち 10000 のことである。 この例のように、コンピュータでは桁が大きい数を e （プログラムによっては大文字の E）を用いて表すので覚えておこう。この e は自然対数の底（ネイピア数）ではないので注意。 Rでのネイピア数は exp(1) である。\n\n\n確認のため、最初の10個分だけ表示してみよう。\n\nres_1[1:10]\n\n [1] NA NA NA NA NA NA NA NA NA NA\n\n\nすべて NA である。\n次に、forループ を使って標本抽出（サンプリング）と母比率の計算を1万回実行する。\\(i\\)番目の結果は、res_1 の \\(i\\)番目の値として保存する。res_1の\\(i\\) 番目は res_1[i] と書く。\n\nfor (i in 1 : 1e4) {\n  x &lt;- sample(pop, size = N, replace = FALSE)\n  res_1[i] &lt;- mean(x == \"female\")\n}\n\nこれで、結果が res_1 に保存された。確認のため、最初の10個の結果を表示してみよう。\n\nres_1[1 : 10]\n\n [1] 0.45 0.54 0.41 0.45 0.44 0.43 0.50 0.52 0.46 0.42\n\n\nさきほどは NA だったところに数値（標本比率）が保存されたことがわかる。\n結果をヒストグラムにしてみよう。私たちは母比率を知っているので、母比率である0.46を赤い線で示す。\n\ndf1 &lt;- tibble(sample = res_1)\nhist1 &lt;- ggplot(df1, aes(x = sample)) +\n  geom_histogram(binwidth = 0.02, \n                 color = \"black\", \n                 fill = \"dodgerblue\") +\n  geom_vline(xintercept = 0.46, \n             color = \"red\", \n             linewidth = 1.5) +\n  labs(x = \"女性の標本比率\", \n       y = \"度数\")\nplot(hist1)\n\n\n\n\nヒストグラムを見ると、一つひとつの標本比率は母比率よりも大きかったり、母比率よりも小さかったりすることがわかる。しかし、平均すると母比率に近い値を得ることができそうだ。\nこのヒストグラムからわかる通り、統計量は分布する（つまり、標本ごとにばらばらの値をとる）。このような標本ごとの分布を 標本分布 (sampling distribution) と呼ぶ（標本分布については、次のトピックで説明する）。\n\n6.2.3 標準誤差 (standard error; SE)\n標本分布に現れる標準偏差（統計量のばらつき）を標準誤差 (standard error; SE) という。このシミュレーションで得られる標準誤差は、\n\nsd(res_1)\n\n[1] 0.04958564\n\n\nである。\n詳しくは次のトピックで説明するが、理論的には \\[\\mbox{SE} = \\frac{母標準偏差}{\\sqrt{標本サイズ}}\\] なので、\n\npi &lt;- 0.46\npop_sd &lt;- sqrt(pi * (1 - pi))\npop_sd / sqrt(100)\n\n[1] 0.04983974\n\n\nになるはずであるが、シミュレーションなので実行する度に値が変わり、理論値に近づいたり離れたりする。"
  },
  {
    "objectID": "pop-n-sample.html#sec-ex10",
    "href": "pop-n-sample.html#sec-ex10",
    "title": "\n6  母集団と標本をシミュレーションで理解する\n",
    "section": "\n6.3 実習課題",
    "text": "6.3 実習課題\n標本サイズ \\(N\\) の値を変えて (\\(N = 25\\), \\(N = 400\\) で)、同様のシミュレーションを実行してみよう。\n\nヒストグラムはどのように変化するだろうか。\n標準誤差はどのように変化するだろうか。"
  },
  {
    "objectID": "lawoflargenumbers.html#sec-prep11",
    "href": "lawoflargenumbers.html#sec-prep11",
    "title": "\n7  シミュレーションを利用して大数の法則を理解する\n",
    "section": "\n7.1 準備",
    "text": "7.1 準備\n必要なパッケージを読み込む。\n\nlibrary(tidyverse)\n\n## 図のなかで日本語を使えるようにする\n## フォントの設定はお好みで\n## （Unix/Linux ではIPAexフォントのインストールが必要かも）\nif (.Platform$OS.type == \"windows\") { # Windows\n  library(fontregisterer)\n  my_font &lt;- \"Yu Gothic\"\n} else if (capabilities(\"aqua\")) { # macOS\n  my_font &lt;- \"HiraginoSans-W3\"\n} else { # Unix/Linux\n  my_font &lt;- \"IPAexGothic\"\n}\ntheme_set(theme_gray(base_size = 9,\n                     base_family = my_font))"
  },
  {
    "objectID": "lawoflargenumbers.html#sec-lln",
    "href": "lawoflargenumbers.html#sec-lln",
    "title": "\n7  シミュレーションを利用して大数の法則を理解する\n",
    "section": "\n7.2 大数の法則 (Law of Large Numbers; LLN)",
    "text": "7.2 大数の法則 (Law of Large Numbers; LLN)\n「公正な（表が出る確率と裏が出る確率が等しい）」コインを使って、大数の法則のシミュレーションを行う。\nコイン投げは、\n\ncoin &lt;- c(\"表\", \"裏\")\nsample(coin, size = 1)\n\n[1] \"裏\"\n\n\nで実行する。\nこれを1回だけ実行したとき、表の比率は、\n\n表が出れば1\n裏が出れば0\n\nである。コイン投げの回数が少ないと、表が出る比率は真の比率である0.5に近くなるとは限らない。\nしかし、大数の法則によると、コインを投げる回数を十分大きくすると、表の比率は0.5 に近づくはずである。Rを使って確かめてみよう。\nまず、コインを投げる回数 n_flips を決める。500に設定してみよう。\n\nn_flips &lt;- 500\n\n次に、結果を記録する容器（ベクトル）を用意する。\n\nratio_1 &lt;- rep(NA, n_flips)\n\n準備ができたので、n_flips回コイン投げを行い、それぞれのコイン投げが終わった時点での表の比率を計算する。\n\ncoins_1 &lt;- sample(coin, size = n_flips, replace = TRUE)\nfor (i in 1:n_flips) {\n  n_head &lt;- sum(coins_1[1:i] == \"表\") # i回目までに何回表が出たか数える\n  ratio_1[i] &lt;- n_head / i            # i回目までの表の比率を計算して記録する\n}\n\nこれで、ratio_1 に結果が記録された。確認のため、最初の5回分を表示してみよう。\n\nratio_1[1:5]\n\n[1] 1.0000000 0.5000000 0.3333333 0.2500000 0.2000000\n\n\n結果を図示しよう。\n\ndf2 &lt;- tibble(N = 1 : n_flips,\n              ratio_1 = ratio_1)\np1 &lt;- ggplot(df2, aes(x = N, y = ratio_1)) +\n  geom_hline(yintercept = 0.5, \n             linetype = \"dashed\") +\n  geom_line(color = \"dodgerblue\") +\n  labs(x = \"試行回数\", \n       y = \"表の割合\")  \nplot(p1)\n\n\n\n\n比率が少しずつ0.5に近づいていくことがわかる。\nもう1度やってみよう。\n\nratio_2 &lt;- rep(NA, n_flips)\ncoins_2 &lt;- sample(coin, size = n_flips, replace = TRUE)\nfor (i in 1 : n_flips) {\n  n_head &lt;- sum(coins_2[1:i] == \"表\") # i回目までに何回表が出たか数える\n  ratio_2[i] &lt;- n_head / i            # i回目までの表の比率を計算して記録する\n}\ndf2$ratio_2 &lt;- ratio_2\np2 &lt;- ggplot(df2, aes(x = N, y = ratio_2)) +\n  geom_hline(yintercept = 0.5,\n             linetype = \"dashed\") +\n  geom_line(color = \"dodgerblue\") +\n  labs(x = \"試行回数\", \n       y = \"表の割合\")  \nplot(p2)\n\n\n\n\nもう1度やってみよう。\n\nratio_3 &lt;- rep(NA, n_flips)\ncoins_3 &lt;- sample(coin, size = n_flips, replace = TRUE)\nfor (i in 1 : n_flips) {\n  n_head &lt;- sum(coins_3[1:i] == \"表\") # i回目までに何回表が出たか数える\n  ratio_3[i] &lt;- n_head / i            # i回目までの表の比率を計算して記録する\n}\ndf2$ratio_3 &lt;- ratio_3\np3 &lt;- ggplot(df2, aes(x = N, y = ratio_3)) +\n  geom_hline(yintercept = 0.5, \n             linetype = \"dashed\") +\n  geom_line(color = \"dodgerblue\") +\n  labs(x = \"試行回数\", \n       y = \"表の割合\")  \nplot(p3)\n\n\n\n\nシミュレーションを実行する度に、異なる軌跡を描きながら、比率が0.5に近づいていく様子が見てとれる。"
  },
  {
    "objectID": "lawoflargenumbers.html#sec-ex11",
    "href": "lawoflargenumbers.html#sec-ex11",
    "title": "\n7  シミュレーションを利用して大数の法則を理解する\n",
    "section": "\n7.3 実習課題",
    "text": "7.3 実習課題\n\nコイン投げの回数 n_flips を減らしたり増やしたりして、シミュレーションを行ってみよう。\n表が出る確率 \\(\\theta = 0.8\\), 裏が出る確率 \\(1-\\theta = 0.2\\)として、同様のシミュレーションを実行してみよう。"
  },
  {
    "objectID": "sampling-distribution.html#sec-prep12",
    "href": "sampling-distribution.html#sec-prep12",
    "title": "\n8  標本分布を理解する\n",
    "section": "\n8.1 準備",
    "text": "8.1 準備\n必要なパッケージを読み込む。\n\nlibrary(tidyverse)\n## 図のなかで日本語を使えるようにする\n## フォントの設定はお好みで\n## （Unix/Linux ではIPAexフォントのインストールが必要かも）\nif (.Platform$OS.type == \"windows\") { # Windows\n  library(fontregisterer)\n  my_font &lt;- \"Yu Gothic\"\n} else if (capabilities(\"aqua\")) { # macOS\n  my_font &lt;- \"HiraginoSans-W3\"\n} else { # Unix/Linux\n  my_font &lt;- \"IPAexGothic\"\n}\ntheme_set(theme_gray(base_size = 9,\n                     base_family = my_font))"
  },
  {
    "objectID": "sampling-distribution.html#sec-simsd",
    "href": "sampling-distribution.html#sec-simsd",
    "title": "\n8  標本分布を理解する\n",
    "section": "\n8.2 標本分布のシミュレーション",
    "text": "8.2 標本分布のシミュレーション\n\n8.2.1 シミュレーション問題の設定\n母集団（成人男性全体）では、平均身長が170cm、身長の標準偏差が5.5cm であり、身長は正規分布に従うことを知っているとする。\n\nmu &lt;- 170     # 母平均\nsigma &lt;- 5.5  # 母標準偏差\n\n以下では、様々な標本サイズで標本を抽出し、その標本の平均身長を求める作業を 1万回ずつ繰り返すことにする。\n\nn_sims &lt;- 1e4  # シミュレーションの繰り返し回数\n\n\n8.2.2 標本サイズ (\\(N\\)) が1のとき\n標本サイズ \\(N = 1\\) で標本を抽出し、標本平均を計算することを10^{4} 回n_sims 回）繰り返す。まず、\\(N\\) を設定する。\n\nN &lt;- 1\n\n1回の標本抽出は、\n\nh &lt;- rnorm(N, mean = mu, sd = sigma)\n\nで行える。標本平均は、\n\nmean(h)\n\n[1] 164.6253\n\n\nである。 これを1万回繰り返せばよい。\n（本当はもっと簡単な方法もあるが） for ループを使ってシミュレーションを実行してみよう。\nまず、結果を保存するために、10^{4} 個の値を保存する容器（ベクトル）を用意する。要素（中身）は NA にしておく。\n\nsim_1 &lt;- rep(NA, n_sims)\n\nシミュレーションを実行する準備が整ったので、forループでシミュレーションを実行する（forループ以外で実行する方法を知っている者は、その方法を利用してよい）。\n\nfor (i in 1:n_sims) {\n  h &lt;- rnorm(N, mean = mu, sd = sigma)\n  sim_1[i] &lt;- mean(h)\n}\n\n結果をヒストグラムにしてみよう。\n\ndf1 &lt;- tibble(sim_1)\nhist1 &lt;- ggplot(df1, aes(x = sim_1, y = after_stat(density))) +\n  geom_histogram(color = \"black\", \n                 fill = \"dodgerblue\") +\n  labs(x = \"身長の標本平均 (cm)\",\n       y = \"確率密度\",\n       title = \"N = 1 の標本分布\")\nplot(hist1)\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\nこのヒストグラムに、平均 170、標準偏差 5.5 の正規分布 (\\(\\mbox{N}(170, 5.5)\\) と表記する) の確率密度曲線を重ね書きしてみよう。\n\ndf1$x &lt;- seq(140, 200, length.out = nrow(df1))\ndf1$dens &lt;- dnorm(df1$x, mean = mu, sd = sigma)\nhist1_2 &lt;- hist1 + \n  geom_line(data = df1, \n            aes(x = x, y = dens), \n            color = \"red\", \n            size = 1.5)\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\nplot(hist1_2)\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n図を見る限り、標本平均の標本分布と、母集団の分布はとてもよく似ている。\n統計量も確かめてみよう。\n\nmean(sim_1) # 標本平均の平均値\n\n[1] 169.9332\n\nsd(sim_1)   # 標本平均の標準偏差 = 標準誤差\n\n[1] 5.460831\n\n\nこのように、標本平均の平均値は母平均とほぼ同じであり、標本平均の標準偏差（これを平均値の標準誤差 (standard errors; SE) と呼ぶ）は、母標準偏差とほぼ同じである。\n\n8.2.3 標本サイズ (\\(N\\)) が2のとき\n標本サイズ \\(N = 2\\) で、同様のシミュレーションを行ってみよう。 まず、\\(N\\) を設定する。\n\nN &lt;- 2\n\nあとは、さきほどと同様のコマンドを実行すればよい。ただし、結果を上書きしないように、結果に異なる名前をつける。\n\nsim_2 &lt;- rep(NA, n_sims) \nfor (i in 1:n_sims) {\n  h &lt;- rnorm(N, mean = mu, sd = sigma)\n  sim_2[i] &lt;- mean(h)  # sim_2 を使う\n}\n\n結果をヒストグラムにしてみよう。\n\ndf2 &lt;- tibble(sim_2)\nhist2 &lt;- ggplot(df2, aes(x = sim_2, y = after_stat(density))) +\n  geom_histogram(color = \"black\", \n                 fill = \"dodgerblue\") +\n  labs(x = \"身長の標本平均 (cm)\",\n       y = \"確率密度\",\n       title = \"N = 2 の標本分布\")\nplot(hist2)\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\nこのヒストグラムに、平均 170、標準偏差 5.5 の正規分布 (\\(\\mbox{Normal}(170, 5.5)\\)) の確率密度曲線を重ね書きしてみよう。\n\nhist2_2 &lt;- hist2 + \n  geom_line(data = df1, \n            aes(x = x, y = dens), \n            color = \"red\", \n            size = 1.5)\nplot(hist2_2)\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n先ほどとは異なり、標本平均の標本分布と、母集団の分布は少し異なる。標本分布の方が、母集団よりも狭い範囲に集まっていることがわかる。\n統計量も確かめてみよう。\n\nmean(sim_2) # 標本平均の平均値\n\n[1] 170.0375\n\nsd(sim_2)   # 標本平均の標準偏差 = 標準誤差\n\n[1] 3.879714\n\n\n上のシミュレーションと同様、標本平均の平均値は母平均とほぼ同じである。しかし、標本平均の標準偏差である標準誤差 (standard errors; SE) は、母標準偏差よりもかなり小さくなっていることがわかる。\n理論的には、標本平均の標準偏差は \\(母標準偏差/\\sqrt{標本サイズ}\\) になるはずである。確かめてみよう。\n\nsigma / sqrt(N)\n\n[1] 3.889087\n\n\nこれは、上で求めた標準誤差にほぼ一致する。\n\n8.2.4 標本サイズ (\\(N\\)) が10のとき\n標本サイズ \\(nN = 10\\) で同様のシミュレーションを行ってみよう。 まず、\\(N\\) を設定する。\n\nN &lt;- 10\n\nあとは、先ほどと同様のコマンドを実行すればよい。ただし、結果を上書きしないように、結果に異なる名前をつける。\n\nsim_3 &lt;- rep(NA, n_sims) \nfor (i in 1:n_sims) {\n  h &lt;- rnorm(N, mean = mu, sd = sigma)\n  sim_3[i] &lt;- mean(h)  # sim_3 を使う\n}\n\n結果をヒストグラムにしてみよう。\n\ndf3 &lt;- tibble(sim_3)\nhist3 &lt;- ggplot(df3, aes(x = sim_3, y = after_stat(density))) +\n  geom_histogram(color = \"black\", \n                 fill = \"dodgerblue\") +\n  labs(x = \"身長の標本平均 (cm)\", \n       y = \"確率密度\",\n       title = \"N = 10 の標本分布\")\nplot(hist3)\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\nこのヒストグラムに、平均 170、標準偏差 5.5 の正規分布 (\\(\\mbox{N}(170, 5.5)\\)) の確率密度曲線を重ね書きしてみよう。\n\nhist3_2 &lt;- hist3 +\n  geom_line(data = df1, \n            aes(x = x, y = dens), \n            color = \"red\", \n            size = 1.5)\nplot(hist3_2)\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n標本分布がさらに狭い範囲に集まっていることがわかる。\n統計量を確かめてみよう。\n\nmean(sim_3) # 標本平均の平均値\n\n[1] 170.037\n\nsd(sim_3)   # 標本平均の標準偏差 = 標準誤差\n\n[1] 1.745465\n\n\n先程と同様、標本平均の平均値は母平均とほぼ同じである。また、標本平均の標準偏差である標準誤差 (standard errors; SE) は、母標準偏差よりもより一層小さくなっていることがわかる。\n理論的には、標本平均の標準偏差は \\(母標準偏差/\\sqrt{標本サイズ}\\) になるはずである。確かめてみよう。\n\nsigma / sqrt(N)\n\n[1] 1.739253\n\n\nこれは、上で求めた標準誤差にほぼ一致する。\n\n8.2.5 実習課題\n標本サイズ \\(N\\) を50、100にして、同様のシミュレーションを実行しよう。どのようなことがわかるか文章にまとめて整理しよう。"
  },
  {
    "objectID": "sampling-distribution.html#sec-error",
    "href": "sampling-distribution.html#sec-error",
    "title": "\n8  標本分布を理解する\n",
    "section": "\n8.3 誤差の分布",
    "text": "8.3 誤差の分布\n標本平均の誤差は、 \\[誤差 = 標本平均 - 母平均\\] と表すことができる。また、標本平均の平均値（期待値）は母平均に等しいので、 \\[誤差 = 標本平均 - 標本平均の平均値\\] でも同じことである。\nしたがって、上で実行した3つのシミュレーション（それぞれ、\\(N = 1, 2, 10\\)）の誤差 err_1, err_2, err_3 は、\n\nerr_1 &lt;- sim_1 - mean(sim_1)\nerr_2 &lt;- sim_2 - mean(sim_2)\nerr_3 &lt;- sim_3 - mean(sim_3)\n\nである。さらに、それぞれを標準誤差（標本平均の標準偏差の推定値）で割ってみる。\n\nz1 &lt;- err_1 / sd(sim_1)\nz2 &lt;- err_2 / sd(sim_2)\nz3 &lt;- err_3 / sd(sim_3)\n\n平均値を引いて、それを標準偏差で割っているので、これは標準化 (standardization あるいは \\(z\\)化) である。\nここで、標準正規分布 \\(\\mbox{Normal}(0, 1)\\) の分布を図にしてみよう。\n\ndf_nml &lt;- tibble(z = seq(from = -4, to = 4, length.out = 1000))\ndf_nml$dens &lt;- dnorm(df_nml$z,  mean = 0, sd = 1)\nstdn &lt;- ggplot(df_nml, aes(x = z, y = dens)) +\n  geom_line() +\n  labs(y = \"確率密度\")\nplot(stdn)\n\n\n\n\nこの図に、先ほど計算した z1, z2, z3 の分布を上書きしてみよう。確率密度 (density) を加えるため、geom_density() を使う。\n\ndf_z &lt;- tibble(z1, z2, z3)\ndens_lines &lt;- stdn +\n  geom_density(data = df_z, \n               aes(x = z1, y = after_stat(density)),\n               color = \"red\") +\n  geom_density(data = df_z, \n               aes(x = z2, y = after_stat(density)), \n               color = \"blue\") +\n  geom_density(data = df_z, \n               aes(x = z3, y = after_stat(density)),\n               color = \"orange\")\nplot(dens_lines)\n\n\n\n\nこのように、標本平均を標準化すると、標準正規分布に似た分布が出てくる（4つの曲線が重なり合っていて区別が難しい）。よって、標準正規分布を利用した推定ができそうに見える（本当にできるかどうかは他の機会に解説する）。"
  },
  {
    "objectID": "sampling-distribution.html#sec-mp4",
    "href": "sampling-distribution.html#sec-mp4",
    "title": "\n8  標本分布を理解する\n",
    "section": "\n8.4 標本分布のシミュレーション",
    "text": "8.4 標本分布のシミュレーション\n標本分布のシミュレーション動画 (MP4) を例として示す\n\n\\(N = 1\\)\n\\(N = 2\\)\n\\(N = 10\\)"
  },
  {
    "objectID": "estimating-mean.html#sec-prep13",
    "href": "estimating-mean.html#sec-prep13",
    "title": "\n9  母平均の推定\n",
    "section": "\n9.1 準備",
    "text": "9.1 準備\n必要なパッケージを読み込む。\n\nlibrary(tidyverse)\n\n## 図のなかで日本語を使えるようにする\n## フォントの設定はお好みで\n## （Unix/Linux ではIPAexフォントのインストールが必要かも）\nif (.Platform$OS.type == \"windows\") { # Windows\n  library(fontregisterer)\n  my_font &lt;- \"Yu Gothic\"\n} else if (capabilities(\"aqua\")) { # macOS\n  my_font &lt;- \"HiraginoSans-W3\"\n} else { # Unix/Linux\n  my_font &lt;- \"IPAexGothic\"\n}\ntheme_set(theme_gray(base_size = 9,\n                     base_family = my_font))"
  },
  {
    "objectID": "estimating-mean.html#sec-defpop13",
    "href": "estimating-mean.html#sec-defpop13",
    "title": "\n9  母平均の推定\n",
    "section": "\n9.2 母集団を定義する",
    "text": "9.2 母集団を定義する\n成人男性の身長に興味があるとする。母集団の人口を100万、母平均を約170cm、母標準偏差を約6cm に設定する。\n\npop &lt;- rnorm(1e6, mean = 170, sd = 6)\n\n母集団の身長分布は以下のようになる。\n\npop_height &lt;- ggplot(tibble(pop), \n                     aes(x = pop, \n                         y = after_stat(density))) +\n  geom_histogram(color = \"black\") +\n  labs(x = \"身長 (cm)\", \n       y = \"確率密度\", \n       title = \"母集団の分布\")\nplot(pop_height)\n\n\n\n\nこの母集団における身長の母平均は、\n\nmean(pop)\n\n[1] 170.0008\n\n\nであり、母標準偏差は、\n\nsd(pop)\n\n[1] 6.001557\n\n\nである。"
  },
  {
    "objectID": "estimating-mean.html#sec-saple13",
    "href": "estimating-mean.html#sec-saple13",
    "title": "\n9  母平均の推定\n",
    "section": "\n9.3 標本を抽出して母平均を推定する",
    "text": "9.3 標本を抽出して母平均を推定する\n\n9.3.1 標本1\n100万人の母集団全員を調べるのではなく、100人だけ標本として抽出し、その標本を利用して母平均を推定してみよう。\n標本サイズ100の標本を1つ抽出する。\n\nN &lt;- 100  # 標本サイズ\nsample_1 &lt;- sample(pop, size = N, replace = FALSE)\n\n\n9.3.1.1 点推定 (point estimation)\n標本平均を計算する。\n\nmean(sample_1)\n\n[1] 169.3795\n\n\nこれが母平均の点推定値 (point estimate) である。\n\n9.3.1.2 区間推定 (interval estimation)\n区間推定では、1つの値を示す代わりに推定に区間を利用することで、推定に対する不確実性（自信のなさ）を示す。\n推定に標準正規分布を利用する場合、身長 \\(h\\) の点推定値を \\(\\bar{h}\\) とすると、以下のように定義される信頼区間 (confidence interval) を区間推定に使う。 \\[\n\\left[\\bar{h} - Q \\cdot \\mathrm{SE}, \\bar{h} + Q \\cdot \\mathrm{SE} \\right].\n\\] ここで、SE は標準誤差 (standard error) で、これは以下のように推定する。 \\[\\mathrm{SE} = \\frac{u}{\\sqrt{N}}.\\] \\(N\\) は標本サイズ、\\(u\\) は不偏分散の平方根（下で説明する）である。\nまた、\\(Q\\)（と\\(-Q\\)） は、どのような信頼区間を求めたいかによって変わる。 例えば、95％信頼区間を求めたいときは、\\(Q = 1.96\\) を使う。\n特定の信頼度（信頼度に何パーセントを使うか）に対するQの求め方は次の通りである。 まず、100%から信頼度を引く。95%の場合 \\(1 - 0.95 = 0.05\\) である。次に、その値を2で割る。 95%の場合、\\(0.05/2= 0.025\\) である。この値を qnorm() 関数に当てはめる。ただし、lower.tail = FALSE を指定する（指定しない場合は\\(-Q\\) が出てくるので、それを利用してもよい）。\n\n(Q_95 &lt;- qnorm((1 - 0.95) / 2, lower.tail= FALSE))\n\n[1] 1.959964\n\n\n小数第2位までで丸めると、\n\nround(Q_95, digit = 2)\n\n[1] 1.96\n\n\nである。\n87%信頼区間を使いたいときは、\n\n(Q_87 &lt;- qnorm( (1 - 0.87) / 2, lower.tail = FALSE))\n\n[1] 1.514102\n\n\nを使う。\n次に、SE（標準誤差）を求めよう。 そのためにまず、標本の分散（不偏分散, unbiased variance）を計算する。身長を \\(h\\)とすると、身長の不偏分散 Var(\\(h\\)) は \\[\\mathrm{Var}(h) = \\frac{\\sum_{i=1}^n (h_i - \\bar{h})^2}{N - 1}\\] と定義される。これは、var() で計算できる。\n\n(var_1 &lt;- var(sample_1))\n\n[1] 37.35728\n\n\nこの平方根が不偏分散の平方根である。\n\n(sd_1 &lt;- sqrt(var_1))\n\n[1] 6.11206\n\n\nこの値はsd() で直接求められる。\n\nsd(sample_1)\n\n[1] 6.11206\n\n\n母分散（母集団の分散）または母標準偏差（母集団の標準偏差）を知らないときは、ここで計算した標本から得られる値を推定値として使う。ここでは、標本の標準偏差（不偏分散の平方根）を母標準偏差の推定値として使おう。 すると、このサンプルから推定されるSEは、\n\n(SE_1 &lt;- sd_1 / sqrt(N))\n\n[1] 0.611206\n\n\nとなる。\n以上から、95%信頼区間の下限は、\n\n(lb &lt;- mean(sample_1) - Q_95 * SE_1)\n\n[1] 168.1816\n\n\n上限は、\n\n(ub &lt;- mean(sample_1) + Q_95 * SE_1)\n\n[1] 170.5775\n\n\nよって、この標本（標本1）から得られる95%信頼区間は、[168.18, 170.58] である。\n\n9.3.2 信頼区間を求める関数を作る\n上で説明した方法で信頼区間を求められるが、以上の内容を標本を抽出し直す度に実行するのは面倒なので、信頼区間 (confidence intervals) を求める関数を作ってしまおう。信頼度は引数を指定して選べるようにする。\n\nget_confint &lt;- function(x, level = 0.95) {\n  ## 標準正規分布を利用して信頼区間を求める関数\n  ## 引数：x = 推定に使う標本（サンプル）\n  ##       level = 信頼度。既定値（デフォルト）は 0.95\n  ## 返り値：点推定値、信頼区間の下限値、信頼区間の上限値の3つを含むベクトル\n  N &lt;- length(x)  # サンプルサイズ\n  mean_x &lt;- mean(x)\n  SE &lt;- sd(x) / sqrt(N)\n  Q &lt;- qnorm((1 - level) / 2, lower.tail = FALSE)\n  lb &lt;- mean_x - Q * SE\n  ub &lt;- mean_x + Q * SE\n  estimates &lt;- c(round(mean_x, 2), round(lb, 2), round(ub, 2))\n  names(estimates) &lt;- c(\"estimate\", \"lower bound\", \"upper bound\")\n  return(estimates)\n}\n\n先ほどのサンプルを使い、この関数が意図した通りに動くか確認しよう。\n\nget_confint(sample_1)\n\n   estimate lower bound upper bound \n     169.38      168.18      170.58 \n\n\n上で求めたのものと同じ結果が得られた。\nこの関数を使って50%信頼区間を求めるには、\n\nget_confint(sample_1, level = 0.5)\n\n   estimate lower bound upper bound \n     169.38      168.97      169.79 \n\n\nとする。\n87%信頼区間は、\n\nget_confint(sample_1, level = 0.87)\n\n   estimate lower bound upper bound \n     169.38      168.45      170.30 \n\n\nで求められる。\n以下ではこの関数を利用しよう。\n\n9.3.3 標本2\n先ほどとは別の標本（サイズは同じ）を抽出して、母平均を推定してみよう。\n\nsample_2 &lt;- sample(pop, size = N, replace = FALSE)\n\n\nget_confint(sample_2)\n\n   estimate lower bound upper bound \n     169.41      168.22      170.59 \n\n\n先ほどとは異なる推定値が得られた。\n\n\n9.3.4 標本3\nもう1度やってみよう。 先ほどとは別の標本（サイズは同じ）を抽出して、母平均を推定してみよう。\n\nsample_3 &lt;- sample(pop, size = N, replace = FALSE)\n\n\nget_confint(sample_3)\n\n   estimate lower bound upper bound \n     169.65      168.44      170.86"
  },
  {
    "objectID": "estimating-mean.html#sec-13sim",
    "href": "estimating-mean.html#sec-13sim",
    "title": "\n9  母平均の推定\n",
    "section": "\n9.4 シミュレーション",
    "text": "9.4 シミュレーション\n標本抽出を何度も繰り返し、推定（の誤差）がどのようにばらつくか確認してみよう。\nまず、シミュレーションの繰り返し回数を決める。1万回にしてみよう。（コンピュータの性能があまり良くない場合は、この回数を少し小さめ [例えば 1e3]　にしたほうがいいかもしれない）。\n\nn_sims &lt;- 1e4\n\n結果を保存する容器を用意する。今回は、1回ごとに保存する値が3つあるので、1万行 \\(\\times\\) 3列の行列 (matrix) を用意する。行 (row) の数は nrow、列 (column) の数は ncol で指定する。いつものシミュレーションと同じように、とりあえず NA を入れておく。\n\nres_sim &lt;- matrix(NA, nrow = n_sims, ncol = 3)\n\n行列の中身をわかりやすくするために、3つの列に名前をつけておこう。名前は、est（estimate, 推定値）、lb（lower bound, 95％信頼区間の下限値)、ub (upper bound, 95％信頼区間の上限値）にする。\n\ncolnames(res_sim) &lt;- c(\"est\", \"lb\", \"ub\")\n\n準備ができたので、forループでシミュレーションを行う。結果を res_sim の \\(i\\) 行目に保存するために、res_sim[i, ] で \\(i\\)行目を指定する。\n\nfor (i in 1:n_sims) {\n  smpl &lt;- sample(pop, size = N, replace = FALSE)\n  res_sim[i,] &lt;- get_confint(smpl)\n}\n\nまず、最初の5つの結果を確認してみよう。\n\nres_sim[1:5, ]\n\n        est     lb     ub\n[1,] 169.15 167.90 170.39\n[2,] 171.05 169.87 172.23\n[3,] 169.95 168.85 171.05\n[4,] 170.46 169.05 171.86\n[5,] 169.81 168.67 170.95\n\n\nこのように、1つの標本から計算された値が各行に保存されている。\n\n9.4.1 不偏性を確認する\n上で実行したシミュレーションの結果を利用して、点推定値のヒストグラムを作ってみよう。点推定値は res_sim の1列目に保存されている。 ggplotで図を描くために、行列をデータフレームに変換しよう。as_tibble() で変換できる。\n\ndf_sim &lt;- as_tibble(res_sim)\n\n中身を確認してみよう。\n\nglimpse(df_sim)\n\nRows: 10,000\nColumns: 3\n$ est &lt;dbl&gt; 169.15, 171.05, 169.95, 170.46, 169.81, 170.30, 169.66, 169.45, 16…\n$ lb  &lt;dbl&gt; 167.90, 169.87, 168.85, 169.05, 168.67, 169.11, 168.55, 168.25, 16…\n$ ub  &lt;dbl&gt; 170.39, 172.23, 171.05, 171.86, 170.95, 171.50, 170.76, 170.65, 17…\n\n\nこのように、行列 res_sim の列名を変数名とするデータフレームができた。あとで使うために、シミュレーションid を通し番号で追加しておく。\n\ndf_sim$id &lt;- 1:n_sims\n\nシミュレーションで得られた点推定値の分布をヒストグラムで確認してみよう。\n\nh_est &lt;- ggplot(df_sim, aes(x = est)) +\n  geom_histogram(color = \"black\", \n                 fill = \"dodgerblue\") +\n  geom_vline(xintercept = mean(pop), \n             color = \"red\") +    # 母平均を赤線で示す\n  labs(x = \"身長の標本平均 (cm)\", \n       y = \"度数\",\n       title = \"標本平均の標本分布\")\nplot(h_est)\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\nこれらの標本平均の平均は母平均に一致するというのが「不偏性」である。確かめてみよう。\n\nmean(df_sim$est)\n\n[1] 170.0055\n\nmean(pop)\n\n[1] 170.0008\n\n\n標本平均の平均と母平均が、ほぼ一致することがわかる。\n\n9.4.2 信頼区間の意味を理解する\n95%信頼区間とは何だろうか。\n1つの信頼区間を取り出してみる。ここでは、79番目の信頼区間を取り出す。79番目にした理由は特にない。\n\nres_sim[79, 2:3]\n\n    lb     ub \n167.53 170.28 \n\n\nこの信頼区間に、真の母平均170.0007993 は含まれているだろうか。母数が区間内にあれば、この95％信頼区間が母数（パラメタ）を区間内に捉えている確率は1 (100%) である。反対に、母数がこの区間内になければ、この95％信頼区間が母数（パラメタ）を区間内に捉えている確率は0である。\n別の信頼区間を取り出してみる。ここでは、5番目の信頼区間を取り出す。5番目を選んだ理由は特にない。\n\nres_sim[5, 2:3]\n\n    lb     ub \n168.67 170.95 \n\n\nこの信頼区間に、真の母平均170.0007993 は含まれているだろうか。母数が区間内にあれば、この95％信頼区間が母数（パラメタ）を区間内に捉えている確率は1 (100%) である。反対に、母数がこの区間内になければ、この95％信頼区間が母数（パラメタ）を区間内に捉えている確率は0である。\nこれを、1つひとつの標本について確かめ、1万回行ったシミュレーションのうち、母数を捉える95%信頼区間がいくつ得られたか数えてみよう。母数を捉えているかどうかは、2つの不等式で判断できる。\n\n95%信頼区間の下限値 \\(\\leq\\) 母数（母平均）\n95%信頼区間の上限値 \\(\\geq\\) 母数（母平均）\n\n上の2つの条件を両方とも満たすとき、信頼区間が母数を捉えているといえる。今回のように、2つの以上の条件があるときは、& で条件を並べる。\n\ncaught &lt;- res_sim[, 2] &lt;= mean(pop) & res_sim[, 3] &gt;= mean(pop)\n\n条件を2つとも満たす場合は TRUE, そうでない（1つでも条件に合わない）場合は FALSE になる。最初の5つ分だけ確認してみよう。\n\ncaught[1:5]\n\n[1] TRUE TRUE TRUE TRUE TRUE\n\n\n母数を捉えた区間の数は TRUE の個数なので、\n\nsum(caught)\n\n[1] 9481\n\n\nである。つまり、1万個の95％信頼区間のうち、母数を捉えることができた区間は 9481個ある。言い換えると、標本抽出と区間推定を繰り返し行うと、得られた95%信頼区間の94.8%（約95％）は、母数を区間内に捉えられる。これが、信頼区間のパーセンテージの意味である。\n理解を深めるために、信頼区間を図示してみよう。 シミュレーションで得た1万個の信頼区間から、50個だけ無作為に選び、選んだ50個の信頼区間を図示してみよう。\nまず、無作為に50個の結果を選ぶ。データフレームから無作為に行を選びたいときは、dplyr パッケージ（tidyverse に含まれる）の slice_sample() を使う。\n\nrdm_50 &lt;- slice_sample(df_sim, n = 50)\n\n選ばれた信頼区間を図示する。\n\nci1 &lt;- ggplot(rdm_50, \n              aes(x = as.factor(id), \n                  y = est, \n                  ymin = lb, \n                  ymax = ub)) +\n  geom_pointrange() +\n  labs(x = \"シミュレーション ID\", \n       y = \"点推定値と95%信頼区間\") +\n  coord_flip()  # x軸とy軸を入れ替える\nplot(ci1)\n\n\n\n\n結果を見やすくするため、点推定値の大きで並べ替えてみよう。並べ替えは、reorder() で行う。 点推定値 (est) が小さい順に並べ替えよう。\n\nci2 &lt;- ggplot(rdm_50, aes(x = as.factor(reorder(id, est)), \n                          y = est, \n                          ymin = lb,\n                          ymax = ub)) +\n  geom_pointrange() +\n  geom_hline(yintercept = mean(pop), \n             color = \"blue\", \n             linetype = \"dashed\") +\n  labs(x = \"シミュレーション ID\", \n       y = \"点推定値と95%信頼区間\") +\n  coord_flip()  # x軸とy軸を入れ替える\nplot(ci2)\n\n\n\n\n95％信頼区間が青い点線の位置を区間内に含めば、その信頼区間は母数を捉えている。反対に、95％信頼区間が青い点線と交わっていないとき、その信頼区間は母数を捉え損ねている。母数を捉え損ねた区間に色をつけてみよう。\nまず、先ほどと同じ条件を使い、母数を捉えているかどうかを調べる。\n\nrdm_50$caught &lt;- rdm_50$lb &lt;= mean(pop) & rdm_50$ub &gt;= mean(pop)\n\nmyd$caught が TRUE の場合とFALSEの場合で線の色と点推定値の形を区別する。\n\nci3 &lt;- ggplot(rdm_50, aes(x = as.factor(reorder(id, est)), \n                          y = est,\n                          ymin = lb, \n                          ymax = ub, \n                          color = caught,\n                          shape = caught)) +\n  geom_pointrange() +\n  geom_hline(yintercept = mean(pop), \n             color = \"black\", \n             linetype = \"dashed\") +\n  labs(x = \"シミュレーション ID\", \n       y = \"点推定値と95%信頼区間\") +\n  scale_color_brewer(palette = \"Set1\",\n                     name = \"母数を捉えることに\", \n                     labels = c(\"失敗\", \"成功\")) +\n  scale_shape_discrete(name = \"母数を捉えることに\", \n                     　labels = c(\"失敗\", \"成功\")) +\n  coord_flip()  # x軸とy軸を入れ替える\nplot(ci3)\n\n\n\n\n50個の95％信頼区間のうち、2個（2/50 = 0.04）の信頼区間が母数を捉え損ねている。 言い換えると、96％（約95％）の信頼区間が母数を捉えることに成功している。 これが95%信頼区間の「95%」の意味である。"
  },
  {
    "objectID": "estimating-mean.html#sec-ex13",
    "href": "estimating-mean.html#sec-ex13",
    "title": "\n9  母平均の推定\n",
    "section": "\n9.5 実習課題",
    "text": "9.5 実習課題\n成人女性の身長に興味があるとする。母集団の人口を100万、母平均を約162cm、母標準偏差を約5cm に設定して、上と同様のシミュレーションを行い、複数の95％信頼区間を図示してみよう。"
  },
  {
    "objectID": "t-distribution.html#sec-prep14",
    "href": "t-distribution.html#sec-prep14",
    "title": "\n10  \\(t\\) 分布を利用した母平均の推定\n",
    "section": "\n10.1 準備",
    "text": "10.1 準備\n必要なパッケージを読み込み、図の日本語が正しく表示されるようにする。\n\nlibrary(tidyverse)\n\n## 図のなかで日本語を使えるようにする\n## フォントの設定はお好みで\n## （Unix/Linux ではIPAexフォントのインストールが必要かも）\nif (.Platform$OS.type == \"windows\") { # Windows\n  library(fontregisterer)\n  my_font &lt;- \"Yu Gothic\"\n} else if (capabilities(\"aqua\")) { # macOS\n  my_font &lt;- \"HiraginoSans-W3\"\n} else { # Unix/Linux\n  my_font &lt;- \"IPAexGothic\"\n}\ntheme_set(theme_gray(base_size = 9,\n                     base_family = my_font))"
  },
  {
    "objectID": "t-distribution.html#sec-14defpop",
    "href": "t-distribution.html#sec-14defpop",
    "title": "\n10  \\(t\\) 分布を利用した母平均の推定\n",
    "section": "\n10.2 母集団を定義する",
    "text": "10.2 母集団を定義する\n成人男性の身長に興味があるとする。母集団の人口を100万、母平均を約170cm、母標準偏差を約6cm に設定する。\n\npop &lt;- rnorm(1e6, mean = 170, sd = 6)\n\n母集団の身長分布は以下のようになる。\n\npop_height &lt;- ggplot(tibble(pop), \n                     aes(x = pop, \n                         y = after_stat(density))) +\n  geom_histogram(color = \"black\") +\n  labs(x = \"身長 (cm)\", \n       y = \"確率密度\", \n       title = \"母集団の分布\")\nplot(pop_height)\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\nこの母集団の身長の平均（母平均）は、\n\nmean(pop)\n\n[1] 169.9955\n\n\nであり、身長の標準偏差（母標準偏差）は、\n\nsd(pop)\n\n[1] 6.011032\n\n\nである。"
  },
  {
    "objectID": "t-distribution.html#sec-14sample",
    "href": "t-distribution.html#sec-14sample",
    "title": "\n10  \\(t\\) 分布を利用した母平均の推定\n",
    "section": "\n10.3 標本を抽出して母平均を推定する",
    "text": "10.3 標本を抽出して母平均を推定する\n\n10.3.1 標本抽出と母平均の推定のシミュレーション\n100万人の母集団で全員を調べるのではなく、10人だけ標本として抜き出して母平均を推定することを考える。 シミュレーションで標本抽出を1万回繰り返し、それぞれの標本で標本平均を計算しよう。\nまず、標本サイズを10に、シミュレーション回数を1万に設定する。\n\nN &lt;- 10          # 標本サイズ\nn_sims &lt;- 1e4    # シミュレーションの繰り返し回数\n\n1万個の標本平均を保存するためのベクトルを用意する。\n\nmeans &lt;- rep(NA, 1e4)\n\nまた、後で使うので、不偏分散の平方根も保存できるようにする。\n\nu &lt;- rep(NA, 1e4)\n\n母集団 pop から標本サイズ N = 10 の標本を抽出する作業を n_sims = 10^{4} 回繰り返し、それぞれで標本平均と不偏分散の平方根を計算する。\n\nfor (i in 1 : n_sims) {\n  smpl &lt;- sample(pop, size = N, replace = FALSE)\n  means[i] &lt;- mean(smpl)\n  u[i] &lt;- sd(smpl)\n}\n\n標本平均の標本分布を確認してみよう。\n\ndf_sim &lt;- tibble(mean = means, \n                 sd = u)\nh1 &lt;- ggplot(df_sim, aes(x = mean)) +\n  geom_histogram(binwidth = 1, \n                 color = \"black\", \n                 fill = \"dodgerblue\") +\n  labs(x = \"身長の標本平均 (cm)\", \n       y = \"度数\")\nplot(h1)\n\n\n\n\nなんとなく正規分布になっているように見えるが、はたしてそうだろうか。 得られた標本平均を標準化して、標準正規分布と分布を比べてみよう。\n\n10.3.1.1 母分散 \\(\\sigma^2\\) を知っているとき\n母分散 \\(\\sigma^2\\)（あるいは母標準偏差 \\(\\sigma\\)）を知っているという特殊な場合について考える。このとき、標本平均 \\(\\bar{x}\\)は、以下の式で標準化 (standardize) できる。\n\\[\nz = \\frac{\\bar{x} - \\mu}{\\frac{\\sigma}{\\sqrt{N}}}.\n\\] 標本平均は不偏推定量なので、 \\[\n\\mathbb{E}[\\bar{x}] = \\mu\n\\] となる。そこで、\\(\\mu\\) は、\n\n(mu &lt;- mean(means))\n\n[1] 169.9729\n\n\nとしよう。\nまた、仮定により \\(\\sigma\\) は知っているので母集団の \\(\\sigma\\) を使う。\n\n(sigma &lt;- sd(pop))\n\n[1] 6.011032\n\n\nこれらの値を使うと、標準化された標本平均 \\(z\\) は、\n\nz &lt;- (means - mu) / (sigma / sqrt(N))\n\nとなる。\nこの \\(z\\) の分布を確認してみよう。\n\ndf_sim$z &lt;- z\nh2 &lt;- ggplot(df_sim, aes(x = z)) +\n  geom_histogram(binwidth = 0.5, \n                 color = \"black\", \n                 fill = \"lightblue\") +\n  labs(title = \"母分散が既知の場合\", \n       y = \"度数\")\nplot(h2)\n\n\n\n\n標準正規分布に似ているように見える。geom_density() を使って \\(z\\) の確率密度曲線（青い点線） を描き、標準正規分布の確率密度曲線（赤い実線）と比べてみよう。\n\ndf_sim$x &lt;- seq(from = -4, to = 4, length.out = nrow(df_sim))\ndf_sim$dens &lt;- dnorm(df_sim$x, mean = 0, sd = 1)\nh3 &lt;- ggplot(df_sim) +\n  geom_histogram(aes(x = z, \n                     y = after_stat(density)),\n                 binwidth = 0.5, \n                 color = \"black\", \n                 fill = \"lightblue\") +\n  geom_density(aes(x = z, \n                   y = after_stat(density)), \n               color = \"blue\", \n               linetype = \"dashed\") +\n  geom_line(aes(x = x, \n                y = dens), \n            color = \"red\") +\n  labs(y = \"確率密度\", \n       title = \"母分散が既知の場合\")\nplot(h3)\n\n\n\n\n2つの確率密度曲線はほぼ一致している。\nこの例のように、母分散を知っているとき、標本平均を標準化した \\(z\\) の分布は標準正規分布に従う。したがって、私たちは区間推定に（これまでどおり）標準正規分布を利用することができる。\n\n10.3.1.2 母分散 \\(\\sigma^2\\) を知らないとき\nしかし、通常私たちは標本しか調べられないので母分散を知らない。母分散を知らないときはどうなるだろうか。\n母分散を知らないとき、先ほどと同じ標準化はできない。なぜなら、上で使った標準化の式には、\\(\\sigma\\) が出てくるが、その値を知らないからだ。そこで、母標準偏差 \\(\\sigma\\) の推定値として、不偏分散の平方根 \\(u\\) を使う。この値は既にuとして保存してある。\nこの \\(u\\) を使い、標本平均 \\(\\bar{x}\\)は、以下の式で標準化する（\\(\\hat{z}\\) は「\\(z\\)ハット」と読む）。 \\[\\hat{z} = \\frac{\\bar{x} - \\mu}{\\frac{u}{\\sqrt{N}}}.\\]\n\nz_hat &lt;- (means - mu) / (u / sqrt(N))\n\nこの \\(\\hat{z}\\) の分布を確認してみよう。\n\ndf_sim$z_hat &lt;- z_hat\nh4 &lt;- ggplot(df_sim, aes(x = z_hat)) +\n  geom_histogram(binwidth = 0.5, \n                 color = \"black\", \n                 fill = \"gray\") +\n  labs(x = expression(hat(z)),\n       y = \"度数\", \n       title = \"母分散が未知の場合\")\nplot(h4)\n\n\n\n\n標準正規分布に似ているように見えるが、どうだろうか。geom_density() を使って \\(\\hat{z}\\)の確率密度曲線（青い点線） を描き、標準正規分布の確率密度曲線（赤い実線）と比べてみよう。\n\nh5 &lt;- ggplot(df_sim) +\n  geom_histogram(aes(x = z_hat, \n                     y = after_stat(density)),\n                 binwidth = 0.5, \n                 color = \"black\", \n                 fill = \"gray\") +\n  geom_density(aes(x = z_hat,\n                   y = after_stat(density)), \n               color = \"blue\", \n               linetype = \"dashed\") +\n  geom_line(aes(x = x, \n                y = dens), \n            color = \"red\") +\n  labs(x = expression(hat(z)), \n       y = \"確率密度\", \n       title = \"母分散が未知の場合\")\nplot(h5)\n\n\n\n\n2つの確率密度曲線は、少しずれている。 2つの確率密度は、0（付近）で最大値をとるという点で同じである。 しかし、分布のばらつきが違う。 平均値付近を比べると、\\(\\hat{z}\\) の分布の方が確率密度が低くなっている。 代わりに、分布の両裾を比べると、\\(\\hat{z}\\) の分布の方が、確率密度が高い。 言い換えると、\\(\\hat{z}\\) の分布は、標準正規分布よりも裾が厚い（重い）分布になっている。\nこの例のように、母分散を知らないとき、標本平均を標準化した \\(\\hat{z}\\) の分布は標準正規分布に従わない。したがって、私たちは区間推定に標準正規分布を利用することができない。\n実は、\\(\\hat{z}\\) の分布は自由度 \\(N - 1\\) の \\(t\\) 分布にしたがっている。 ためしに（シミュレーションで使ったサンプル\\(N\\)は 10なので）自由度9の\\(t\\)分布の確率密度曲線（赤い実線）を重ね書きしてみよう。\n\ndf_sim$tdens &lt;- dt(df_sim$x, df = 9)\nh6 &lt;- ggplot(df_sim) +\n  geom_histogram(aes(x = z_hat, \n                     y = after_stat(density)),\n                 binwidth = 0.5, \n                 color = \"black\", \n                 fill = \"gray\") +\n  geom_density(aes(x = z_hat, \n                   y = after_stat(density)), \n               color = \"blue\", \n               linetype = \"dashed\") +\n  geom_line(aes(x = x, y = tdens), \n            color = \"red\") +\n  labs(x = expression(hat(z)), \n       y = \"確率密度\", \n       title = \"母分散が未知の場合\")\nplot(h6)\n\n\n\n\nこのように、確率密度曲線がほぼ一致する。\n\n10.3.1.3 \\(\\ast\\)分布の比べ方\n上の例では、確率密度曲線を重ね書きすることで分布を比較した。 もう少し厳密に分布を比べたいとき、特に2つの分布が同じ分布といえるかどうか確かめたいときには、Q-Qプロット (qunatile-quantile plot) という図を使う。\nこの図では、分布を確かめる対象となるシミュレーションで得た変数の分位点 (quantile) を縦軸に、比較対象の分布の分位点を横軸にとる。分位点と分位点を比べるので、Q-Q プロットと呼ばれる。\n分位点とは、簡単に言うと、「確率分布で下からa%分に相当する値はいくつか」という値である。標準正規分布では、2.5%の分位点 (「2.5パーセンタイル」と呼ばれる) は\\(-1.96\\)、50%の分位点（50パーセンタイル）は0、97.5％の分位点は1.96 である。 Rでは、quantile() で分位点を求めることができる。\n\nquantile(z, probs = c(0.025, 0.5, 0.975))\n\n        2.5%          50%        97.5% \n-1.968565253 -0.001995798  1.922012245 \n\n\nシミュレーションで得た \\(z\\) の分布については、2.5パーセンタイルが -1.97、50パーセンタイルが0、97.5パーセンタイルが 1.92 であることがわかる。\n2つの分布がもし完全に一致するなら、2つの分布の a% の分位点は、aがどんな値であっても等しいはずである。したがって、片方の分布の分位点を \\(y\\)、もう一方の分布の分位点を \\(x\\) とすれば、2つの分布が等しいときには \\(y=x\\) になるはずである。つまり、yとxの散布図の点が45度線の上にすべて乘るはずである。\nこの性質を利用し、Q-Qプロット上の点が45度線の上にあるかどうか（45度線からどれだけずれているか）を調べることで、分布を比較してみよう。\nまず、\\(z\\)（母分散を知っているときに、標本平均を標準化したもの; sample）と標準正規分布 (qnorm) を比べてみよう。 標準正規分布と比較するためのQ-Qプロットは、stat_qq() で作れる。\n\nqq1 &lt;- ggplot(df_sim, aes(sample = z)) + \n  geom_abline(intercept = 0, \n              slope = 1, \n              linetype = \"dashed\") +  # 45度線 \n  stat_qq(distribution = qnorm) +\n  coord_fixed(ratio = 1) +       　   # 図の縦横比を1:1にする\n  labs(x = \"標準正規分布\", \n       y = \"シミュレーションで得たz\")\nplot(qq1)\n\n\n\n\nシミュレーションなので多少のずれはあるものの、点がほぼ45度線上にあることがわかる。\n次に、\\(\\hat{z}\\)（母分散を知らないときに、標本平均を標準化したもの）と標準正規分布を比べてみよう。\n\nqq2 &lt;- ggplot(df_sim, aes(sample = z_hat)) + \n  geom_abline(intercept = 0, \n              slope = 1, \n              linetype = \"dashed\") +  # 45度線 \n  stat_qq(distribution = qnorm) +\n  xlim(-6, 6) + ylim(-6, 6) +\n  coord_fixed(ratio = 1) +            # 図の縦横比を1:1にする\n  labs(x = \"標準正規分布\", \n       y = expression(paste(\"シミュレーションで得た\", hat(z))))\nplot(qq2)\n\nWarning: Removed 4 rows containing missing values (`geom_point()`).\n\n\n\n\n\n先ほどとは異なり、点が45度線から大きくずれている。ここから、\\(\\hat{z}\\)は標準正規分布に従わないことがよりはっきりとわかる。特に、裾（図の両端）で標準正規分布との違いが大きいことがわかるだろう。\n最後に、\\(\\hat{z}\\)（母分散を知らないときに、標本平均を標準化したもの）と自由度9の\\(t\\)分布 (qt(df = 9)) を比べてみよう。\n\nqq3 &lt;- ggplot(df_sim, aes(sample = z_hat)) + \n  geom_abline(intercept = 0,\n              slope = 1,\n              linetype = \"dashed\") +  # 45度線 \n  stat_qq(distribution = qt, dparams = 9) +\n  xlim(-6, 6) + ylim(-6, 6) +\n  coord_fixed(ratio = 1) +            # 図の縦横比を1:1にする\n  labs(x = \"自由度9のt分布\",\n       y = expression(paste(\"シミュレーションで得た\", hat(z))))\nplot(qq3)\n\nWarning: Removed 4 rows containing missing values (`geom_point()`).\n\n\n\n\n\nやはり多少のずれはあるものの、ほとんどの点が45度線上に乗っていることがわかる。よって、\\(\\hat{z}\\)は、自由度9の\\(t\\)分布に従っていると言えそうである（少なくとも、「自由度9の\\(t\\)分布に従っていない」とはっきり言うことはできない）。"
  },
  {
    "objectID": "t-distribution.html#sec-tdist",
    "href": "t-distribution.html#sec-tdist",
    "title": "\n10  \\(t\\) 分布を利用した母平均の推定\n",
    "section": "\n10.4 \\(t\\) 分布を理解する",
    "text": "10.4 \\(t\\) 分布を理解する\n\\(t\\) 分布は、自由度 \\(df &gt; 0\\) によってその形を変える。\nたとえば、自由度1, 2, 10の \\(t\\)乗分布は以下のように分布する。比較のため、標準正規分布も一緒に示す。\nまず、データフレームを作る。\n\nx1 &lt;-  seq(-3, 3, length = 1000)\nstdn &lt;- dnorm(x1, mean = 0, sd = 1)\nt1 &lt;- dt(x1, df = 1)\nt2 &lt;- dt(x1, df = 2)\nt10 &lt;- dt(x1, df = 10)\ndf_t &lt;- tibble(x = rep(x1, 4),\n               t = c(stdn, t1, t2, t10),\n               group = rep(c(\"stdn\", \"t1\", \"t2\", \"t10\"), rep(1000, 4)))\nglimpse(df_t)\n\nRows: 4,000\nColumns: 3\n$ x     &lt;dbl&gt; -3.000000, -2.993994, -2.987988, -2.981982, -2.975976, -2.969970…\n$ t     &lt;dbl&gt; 0.004431848, 0.004512344, 0.004594136, 0.004677241, 0.004761679,…\n$ group &lt;chr&gt; \"stdn\", \"stdn\", \"stdn\", \"stdn\", \"stdn\", \"stdn\", \"stdn\", \"stdn\", …\n\n\n図を作る（この図の作り方は理解できなくてもよい）。\n\nplt_t &lt;- ggplot(df_t, aes(x = x, y = t, \n                          color = group, linetype = group)) +\n  geom_line() +\n  scale_color_brewer(palette = \"Accent\",\n                     name = \"\", \n                     labels = c(\"標準正規分布\", \"t(df = 1)\",\n                                \"t(df = 2)\", \"t(df = 10)\")) +\n  scale_linetype_discrete(name = \"\", \n                          labels = c(\"標準正規分布\", \"t(df = 1)\",\n                                     \"t(df = 2)\", \"t(df = 10)\")) +\n  labs(x = \"\", y = \"確率密度\")\nplot(plt_t)\n\n\n\n\n\\(t\\)分布の特徴として、\n\n0を中心として左右対称\n標準正規分布より山の頂上が低く、裾が厚い（重い）\n自由度が大きくなるほど標準正規分布に近づく\n\nという点が挙げられらる。\n\\(t\\)分布の形状を確認するための関数を用意したので、これを使って色々な\\(t\\)分布の形状を確認し、\\(t\\)分布の特徴を理解しよう（この関数の中身を理解する必要はない）。\n\nplot_t &lt;- function(df) {\n  x &lt;- seq(from = -4, to = 4, length = 1000)\n  t &lt;- dt(x, df = df)\n  nml &lt;- dnorm(x, mean = 0, sd = 1)\n  d &lt;- tibble(x, t, nml)\n  p &lt;- ggplot(d, aes(x = x)) +\n    geom_line(aes(y = nml), linetype = \"dashed\") +\n    geom_line(aes(y = t), color = \"royalblue\") +\n    labs(x = \"\", y = \"確率密度\",\n         title = str_c(\"自由度\", df, \"のt分布（青い実線）と標準正規分布（黒い点線）\"))\n  plot(p)\n}\n\n自由度1の\\(t\\)分布は、\n\nplot_t(df = 1)\n\n\n\n\n自由度3の \\(t\\)分布は、\n\nplot_t(df = 3)\n\n\n\n\nとなることが確認できる。\n実習課題\n自由度 (df) の値をによって\\(t\\)分布がどのように変化するか、関数 plot_t() を使って確かめてみよう。"
  },
  {
    "objectID": "t-distribution.html#sec-estwt",
    "href": "t-distribution.html#sec-estwt",
    "title": "\n10  \\(t\\) 分布を利用した母平均の推定\n",
    "section": "\n10.5 \\(t\\) 分布を利用した区間推定",
    "text": "10.5 \\(t\\) 分布を利用した区間推定\n\\(t\\) 分布を使った区間推定の方法も、基本的に標準正規分布を使った推定方法と同じである。 身長 \\(x\\) の点推定値を \\(\\bar{x}\\) とすると、以下のように定義される信頼区間 (confidence interval) を区間推定に使う。\n\\[\n\\left[\\bar{h} - t_{N-1, p} \\cdot \\mathrm{SE}, \\bar{h} + t_{N-1, p} \\cdot \\mathrm{SE} \\right].\n\\]\n標準正規分布で \\(Q\\) と表していた値（qnorm() で求めた）を\\(t_{N-1, p}\\) （qt() で求める）に変えただけである。\n母集団から \\(N=10\\) の標本を1つ取り出して、身長の母平均を推定してみよう。\n\nsmpl_1 &lt;- sample(pop, size = 10, replace = FALSE)\n\n身長 \\(x\\) の母平均の点推定値 \\(\\bar{x}\\) は、\n\n(x_bar &lt;- mean(smpl_1))\n\n[1] 167.7088\n\n\nである。\nまた、標準誤差は、\\[\\mathrm{SE} = \\frac{u}{\\sqrt{N}}\\] だから、\n\n(se &lt;- sd(smpl_1) / sqrt(10))\n\n[1] 2.283386\n\n\nである。\nここで、標本サイズ\\(N = 10\\) だから、区間推定を行うには自由度 \\(N - 1 = 9\\) の \\(t\\) 分布を利用する。95パーセント信頼区間を求めたいとすると、\\(t\\)分布の下側2.5%分と、上側2.5%分を除外したい。そのために必要なのが、\\(t_{9, 0.025}\\)（または、\\(-t_{9, 0.025}\\)）の値である。これを qt() で求める。\n\nqt(df = 9, p = 0.025)  # 下側\n\n[1] -2.262157\n\n## qt(df = 9, p = 0.025, lower.tail = FALSE)  # 上側\n## qt(df = 9, p = 0.975)  # 上側はこれでも求められる\n\nこれらの値を使うと、母平均の95%信頼区間を求める。\n\n(lb &lt;- x_bar + qt(df = 9, p = 0.025) * se)\n\n[1] 162.5434\n\n(ub &lt;- x_bar + qt(df = 9, p = 0.975) * se)\n\n[1] 172.8742\n\n\nよって、母平均の95%信頼区間は、[162.54, 172.87] である。\nちなみに、\\(t\\) 分布の代わりに標準正規分布を使って95%信頼区間を求めると、\n\n(lb_n &lt;- x_bar + qnorm(p = 0.025) * se)\n\n[1] 163.2335\n\n(ub_n &lt;- x_bar + qnorm(p = 0.975) * se)\n\n[1] 172.1842\n\n\nとなり、[163.23, 172.18] という区間が得られる。この区間は、\\(t\\)分布を使って求めた区間よりも短い。 つまり、標準正規分布を使うと、不確実性を低く見積もり、「自信過剰な」信頼区間を出してしまう。結果として、標本抽出を繰り返しても95%信頼区間が正解を出す確率が95%よりも低くなってしまうので注意が必要である。\n最後に、\\(t\\) 分布を使って区間推定を行う関数を作っておこう。\n\nget_ci &lt;- function(x, level = 0.95) {\n  ## t 分布を利用して母平均の95%信頼区間を求める関数\n  ## 引数：x = 標本（観測値のベクトル）\n  ##       level = 信頼度（既定値は0.95）\n  N &lt;- length(x)  # 標本サイズを調べる\n  x_bar &lt;- mean(x)\n  se &lt;- sd(x) / sqrt(N)\n  t &lt;- qt(df = N - 1, p = (1 - level) / 2, lower.tail = FALSE)\n  lb &lt;- x_bar - t * se\n  ub &lt;- x_bar + t * se\n  confint &lt;- c(下限値 = lb, 上限値 = ub)\n  message(paste0(level * 100, \"%信頼区間\"))\n  return(confint)\n}\n\nこの関数を使ってみよう。標本1 (smpl_1) から得られる母平均の95%信頼区間は、\n\nget_ci(smpl_1)\n\n95%信頼区間\n\n\n  下限値   上限値 \n162.5434 172.8742 \n\n\nとなり、先ほどと同じ結果が得られた。\n89%信頼区間は、\n\nget_ci(smpl_1, level = 0.89)\n\n89%信頼区間\n\n\n  下限値   上限値 \n163.6606 171.7571 \n\n\nである。\n99.9%信頼区間は、\n\nget_ci(smpl_1, level = 0.999)\n\n99.9%信頼区間\n\n\n  下限値   上限値 \n156.7921 178.6255 \n\n\nである。"
  },
  {
    "objectID": "mean-comparison.html#sec-prep15",
    "href": "mean-comparison.html#sec-prep15",
    "title": "\n11  統計的検定と平均値の比較\n",
    "section": "\n11.1 準備",
    "text": "11.1 準備\n必要なパッケージを読み込み、図の日本語が正しく表示されるようにする。\n\nlibrary(tidyverse)\n\n## 図のなかで日本語を使えるようにする\n## フォントの設定はお好みで\n## （Unix/Linux ではIPAexフォントのインストールが必要かも）\nif (.Platform$OS.type == \"windows\") { # Windows\n  library(fontregisterer)\n  my_font &lt;- \"Yu Gothic\"\n} else if (capabilities(\"aqua\")) { # macOS\n  my_font &lt;- \"HiraginoSans-W3\"\n} else { # Unix/Linux\n  my_font &lt;- \"IPAexGothic\"\n}\ntheme_set(theme_gray(base_size = 9,\n                     base_family = my_font))"
  },
  {
    "objectID": "mean-comparison.html#sec-15test",
    "href": "mean-comparison.html#sec-15test",
    "title": "\n11  統計的検定と平均値の比較\n",
    "section": "\n11.2 統計的検定",
    "text": "11.2 統計的検定\n\n11.2.1 有意水準の意味を理解する：帰無仮説が正しい場合の仮説検定シミュレーション\n標準正規分布に従う変数 \\(X\\) について考える。つまり、\n\\[\nX \\sim  \\mbox{Normal}(\\mu = 0, \\sigma = 1)\n\\] と表記される確率変数\\(X\\)を考える。\n私たちが母数（パラメタ）を知らないと仮定して、この集団からランダムに標本を抽出し、以下の仮説を検証する。\n\n帰無仮説：\\(\\mu = 0\\)\n\n対立仮説：\\(\\mu \\neq 0\\)\n\n\n有意水準を5% に設定し、検定を行う。実際には帰無仮説のほうが正しいので、帰無仮説を棄却しないことが望ましい。母数を知らずに検定を行った場合、どのような結果が得られるだろうか。\n\n11.2.1.1 1つの標本で検定を行う\n\nまず、標本を抽出する。標本サイズ \\(N = 20\\) に設定しよう。\n\nN &lt;- 20\nsmp_1 &lt;- rnorm(N, mean = 0, sd = 1)  # 標準正規分布からの乱数生成\n\nこの標本の標本平均は、\n\nmean(smp_1)\n\n[1] -0.03801574\n\n\nである。 この標本平均は0ではない。つまり \\(\\bar{x} \\neq 0\\) であるが、ここから、\\(\\mu \\neq 0\\)と言えるだろうか？\n標本平均の分布は自由度 \\(N - 1\\) の \\(t\\) 分布に従うので、\\(t\\) 分布を利用して検定を行う（このような検定を、\\(t\\) 検定と呼ぶ）。\nある標本を利用して、「母平均が0」という帰無仮説を検証したいときは、t.test() という関数を使う。\n対立仮説が「母平均は0ではない」のときは、次のようにする。\n\n(res_1 &lt;- t.test(smp_1))\n\n\n    One Sample t-test\n\ndata:  smp_1\nt = -0.18469, df = 19, p-value = 0.8554\nalternative hypothesis: true mean is not equal to 0\n95 percent confidence interval:\n -0.4688457  0.3928142\nsample estimates:\n  mean of x \n-0.03801574 \n\n\nこの結果の読み方を説明しよう。まず、data: smp_1 というところに、検定に利用した標本が示される。次の行を見ると、検定統計量 \\(T\\) の値が t = で 示された後、自由度 (df) と\\(p\\) 値 (p-value) が表示される（\\(p\\)値については「計量経済学」の講義で説明する [説明しないかもしれないが、\\(p\\) 値は使わない方針なので問題ない]）。検定統計量の絶対値 \\(|T|\\) が、自ら決めた有意水準における臨界値の絶対値 |\\(c\\)| より大きいとき、帰無仮説を棄却する。検定統計量自体は、次のようにすれば取り出せる。\n\nres_1$statistic\n\n         t \n-0.1846851 \n\n\nまた、自由度 \\(N - 1\\) の \\(t\\) 分布で、有意水準が5%のときに必要な臨界値は、\n\nqt(p = 0.05 / 2, df = N - 1)\n\n[1] -2.093024\n\n\nである。この2つの値の絶対値同士を比べると、\\[|T| &lt; |c|\\] だから、帰無仮説は棄却されない。つまり、\\(\\mu = 0\\) を否定する証拠はない。\n実際、\\(\\mu = 0\\)ということを私たちは知っているので、これは妥当な結論である。標本抽出と仮説検定を繰り返したら、どんなことが起きるだろうか？\n\n\n\n\n\n\nImportant\n\n\n\n\\(p\\)値というのは統計学の中でもとりわけ難しい概念である。大学教員のなかにものその意味を正しく理解していない人がいるくらいである（皆が統計学を専門としているわけではないのでしかたない）。よって、かなり真剣に統計学を勉強する気がある者以外は、\\(p\\)値には関わらないほうがよいだろう。意味もわからずに卒業論文に\\(p\\)値を掲載すると、質疑応答で困った事態になることが予想される。\n「計量経済学」を受講してくれれば説明はする予定である（気が変わるかもしれないが）。\n\n\n\n11.2.1.2 仮説検定のシミュレーション\n\nまず、標本抽出と仮説検定を1回行い、帰無仮説 (null hypothesis) を棄却しないときは null を、帰無仮説を棄却して対立仮説 (alternative hypothesis) を採用するときは alt を返す関数を作る。 有意水準 (level) と標本サイズは自分で設定できるようにしておく。\n\nsmp_test &lt;- function(N = 10, level = 0.05) {\n  ## 標本を抽出し、「母平均 = 0」という仮説を検定する関数\n  ## 引数：N = 標本サイズ（既定値は10）\n  ##       level = 有意水準（既定値は0.05）\n  smp &lt;- rnorm(N, mean = 0, sd = 1)  # 標準正規分布から乱数を生成する\n  test &lt;- t.test(smp)\n  judge &lt;- abs(test$statistic) &gt; abs(qt(p = level / 2, df = N - 1)) \n  res &lt;- ifelse(judge, \"alt\", \"null\")\n  return(res)\n}\n\n\n\n\n\n\n\nNote\n\n\n\nabs() は絶対値 (absolute values) を計算する関数である。\n\n\n試しにこの関数を使ってみると、\n\nsmp_test(N = 20, level = 0.05)\n\n     t \n\"null\" \n\n\nというように、1つの標本からどちらの仮説を採用したかがわかる。\n標本サイズ \\(N = 20\\)、有意水準5% で、この作業を10,000回繰り返してみよう。関数を繰り返し実行する際は、replicate() を使うのが便利である。\n\nn_sims &lt;- 1e4\nsim_1 &lt;- replicate(n_sims, smp_test(N = 20, level = 0.05))\n\nsim_1 の中に、10,000個の検定結果が保存されたはずである。最初の5個だけ確認してみよう。\n\nsim_1[1 : 5]\n\n     t      t      t      t      t \n\"null\" \"null\" \"null\" \"null\" \"null\" \n\n\n結果が保存されていることが確認できる。\nでは、それぞれの仮説はそれぞれ何回ずつ採用されただろうか？表 (table) にしてみよう。\n\ntable(sim_1)\n\nsim_1\n alt null \n 484 9516 \n\n\n割合を表示するために、シミュレーション回数で割ると、\n\ntable(sim_1) / n_sims\n\nsim_1\n   alt   null \n0.0484 0.9516 \n\n\nとなる。 このように、対立仮説が約5%、帰無仮説が95%の検定で採用されている。\n私たちは、上で \\(\\mu=0\\) と設定しているので、帰無仮説こそが正しい仮説である。しかし、帰無仮説が正しくても、5%分の検定では、誤って帰無仮説を棄却し、対立仮説を採用してしまう。この誤りのことを、「第1種の誤り (Type I error)」と呼ぶ。第1種の誤りの確率は、有意水準に一致する。私たちは有意水準5%を選んだので、約5%の検定で第1種の誤りをおかしてしまう。\n有意水準を1%にして、本当にそうなるか確かめてみよう。\n\nsim_2 &lt;- replicate(n_sims, smp_test(N = 20, level = 0.01))\ntable(sim_2) / n_sims\n\nsim_2\n   alt   null \n0.0112 0.9888 \n\n\n第1種の誤り（null が正しいのに alt を採用）の割合は、約1%である。\n有意水準を14%にすると、\n\nsim_3 &lt;- replicate(n_sims, smp_test(N = 20, level = 0.14))\ntable(sim_3) / n_sims\n\nsim_3\n  alt  null \n0.136 0.864 \n\n\n第1種の誤り（null が正しいのに alt を採用）の割合は、約14%になる。\n実習課題： 第1種の誤りは、標本サイズの影響を受けるだろうか? 有意水準を固定し、標本サイズ \\(N\\) を10, 20, 100, 200 と変えて、第1種の誤りの割合をシミュレーションしてみよう！\n\n11.2.2 危険率、検出力、標本サイズ：対立仮説が正しい場合の仮説検定シミュレーション\n平均3、標準偏差2の正規分布に従う変数 \\(Y\\) について考える。すなわち、\n\\[\nY \\sim \\mbox{Normal}(\\mu = 3, \\sigma = 2)\n\\] となる変数 \\(Y\\) について考える。\n私たちが母数を知らないと仮定して、この集団からランダムに標本を抽出し、以下の仮説を検証する。\n\n帰無仮説：\\(\\mu = 0\\)\n\n対立仮説：\\(\\mu \\neq 0\\)\n\n\n有意水準を5% に設定し、検定を行う。実際には対立仮説のほうが正しいので、帰無仮説を棄却したい。母数を知らずに検定を行った場合、どのような結果が得られるだろうか。\n\n11.2.2.1 1つの標本で検定を行う\n\nまず、標本を抽出する。標本サイズ \\(N = 20\\) に設定しよう。\n\nN &lt;- 20\nsmp_2 &lt;- rnorm(N, mean = 3, sd = 2)  # N(3, 2) からの乱数生成\n\nこの標本の標本平均は、\n\nmean(smp_2)\n\n[1] 3.266277\n\n\nである。 この標本平均は0ではない。つまり \\(\\bar{y} \\neq 0\\) であるが、ここから、\\(\\mu \\neq 0\\)と言えるだろうか？\n標本平均の分布は自由度 \\(N - 1\\) の \\(t\\) 分布に従うので、\\(t\\) 分布を利用して検定を行う。\n先ほど同様、t.test() を使う。仮説は先ほどと同じなので、次のようにする。\n\n(res_2 &lt;- t.test(smp_2))\n\n\n    One Sample t-test\n\ndata:  smp_2\nt = 8.1698, df = 19, p-value = 1.225e-07\nalternative hypothesis: true mean is not equal to 0\n95 percent confidence interval:\n 2.429488 4.103067\nsample estimates:\nmean of x \n 3.266277 \n\n\n検定統計量 \\(T\\) の値は、\n\nres_2$statistic\n\n       t \n8.169789 \n\n\nである。 また、自由度 \\(N - 1\\) の \\(t\\) 分布で、有意水準が5%のときに必要な臨界値は、\n\nqt(p = 0.05 / 2, df = N - 1)\n\n[1] -2.093024\n\n\nである。この2つの値の絶対値同士を比べると、\\[|T| &gt; |c|\\] だから、帰無仮説は棄却される。\n実際、\\(\\mu = 2\\)ということを私たちは知っているので、これは妥当な結論であるが、標本抽出と仮説検定を繰り返したら、どんなことが起きるだろうか？\n\n11.2.2.2 仮説検定のシミュレーション\n\nまず、標本抽出と仮説検定を1回行い、帰無仮説 (null hypothesis) を棄却しないときは null を、帰無仮説を棄却して対立仮説 (alternative hypothesis) を採用するときは alt を返す関数を作る。 先ほど作った関数を改良し、母平均と母標準偏差も自分で設定できるようにする。\n\nsmp_test_2 &lt;- function(N = 10, level = 0.05, mu = 0, sigma = 1) {\n  ## 標本を抽出し、「母平均 = 0」という仮説を検定する関数\n  ## 引数：N = 標本サイズ（既定値は10）\n  ##       level = 有意水準（既定値は0.05）\n  ##       mu = 母平均（既定値は0）\n  ##       sigma = 母標準偏差（既定値は1）\n  smp &lt;- rnorm(N, mean = mu, sd = sigma)  # 正規分布から乱数を生成する\n  test &lt;- t.test(smp)\n  judge &lt;- abs(test$statistic) &gt; abs(qt(p = level / 2, df = N - 1))\n  res &lt;- ifelse(judge, \"alt\", \"null\")\n  return(res)\n}\n\n試しにこの関数を使ってみると、\n\nsmp_test_2(N = 20, level = 0.05, mu = 2, sigma = 3)\n\n    t \n\"alt\" \n\n\nというように、1つの標本からどちらの仮説を採用したかがわかる。\n標本サイズ \\(N = 20\\)、有意水準5% で、この作業を10,000回繰り返してみよう。\n\nn_sims &lt;- 1e4\nsim_11 &lt;- replicate(n_sims, smp_test_2(N = 20, level = 0.05, mu = 2, sigma = 3))\n\nsim_11 の中に、10,000個の検定結果が保存されたはずである。最初の5個だけ確認してみよう。\n\nsim_11[1:5]\n\n     t      t      t      t      t \n\"null\"  \"alt\"  \"alt\"  \"alt\"  \"alt\" \n\n\n結果が保存されていることが確認できる。\nでは、それぞれの仮説はそれぞれ何割ずつ採用されただろうか？表 (table) にしてみよう。\n\ntable(sim_11) / n_sims\n\nsim_11\n   alt   null \n0.8103 0.1897 \n\n\nこのように、対立仮説が約81%、帰無仮説が約19%の検定で採用されている。\n私たちは、上で \\(\\mu=2\\) と設定しているので、対立仮説こそが正しい仮説である。しかし、対立仮説が正しくても、19%分の検定では、帰無仮説を棄却せず、対立仮説を採用できない。この誤りのことを、「第2種の誤り (Type II error)」と呼ぶ。第2種の誤りの確率は、どうやって決まるのだろうか？\n有意水準を1%にして、第2種の誤りの割合を計算してみよう。\n\nsim_12 &lt;- replicate(n_sims, smp_test_2(N = 20, level = 0.01, mu = 2, sigma = 3))\ntable(sim_12) / n_sims\n\nsim_12\n   alt   null \n0.5645 0.4355 \n\n\n第2種の誤り（null が正しいのに alt を採用 alt が正しいのに null を採用）の割合は、約44%である。有意水準を小さくしたところ、第2種の誤りの割合が大きくなった。\n今度は、有意水準を10%にしてみよう。\n\nsim_13 &lt;- replicate(n_sims, smp_test_2(N = 20, level = 0.1, mu = 2, sigma = 3))\ntable(sim_13) / n_sims\n\nsim_13\n   alt   null \n0.8968 0.1032 \n\n\n第2種の誤り（null が正しいのに alt を採用）の割合は、約10%である。有意水準を大きくしたところ、第2種の誤りの割合が小さくなった。\nこのように、第2種の誤りの確率は、有意水準と負の相関関係をもつ。第2種の誤りをおかす確率を小さくするためには、有意水準を大きくすればよい。しかし、有意水準は、それ自体が第1種の誤りの確率を表しているので、有意水準を大きくするということは、第1種の誤りの確率が大きくなるということである。\n有意水準を変えずに、第2種の誤りの確率を小さくすることはできないだろうか。 第2種の誤りを小さくするには、「0との違い」を見つけ出す力を強めればよい。つまり、小さな違いでも違いとして見つけ出すことができれば、帰無仮説を棄却することができるようになり、第2種の誤りの確率は小さくなる。このような力のことを検出力 (power) と呼ぶ。検出力は標本サイズに依存する。\n有意水準を5%にして、標本サイズを 10, 20, 50, 100, 200 と変えて、第2種の誤りの割合を計算してみよう。\n\\(N = 10\\) のとき。\n\nsim_14 &lt;- replicate(n_sims, smp_test_2(N = 10, level = 0.05, mu = 2, sigma = 3))\ntable(sim_14) / n_sims\n\nsim_14\n   alt   null \n0.4725 0.5275 \n\n\n\\(N = 20\\) のとき。\n\nsim_15 &lt;- replicate(n_sims, smp_test_2(N = 20, level = 0.05, mu = 2, sigma = 3))\ntable(sim_15) / n_sims\n\nsim_15\n   alt   null \n0.8153 0.1847 \n\n\n\\(N = 50\\) のとき。\n\nsim_16 &lt;- replicate(n_sims, smp_test_2(N = 50, level = 0.05, mu = 2, sigma = 3))\ntable(sim_16) / n_sims\n\nsim_16\n   alt   null \n0.9956 0.0044 \n\n\n\\(N = 100\\) のとき。\n\nsim_17 &lt;- replicate(n_sims, smp_test_2(N = 100, level = 0.05, mu = 2, sigma = 3))\ntable(sim_17) / n_sims\n\nsim_17\nalt \n  1 \n\n\n\\(N = 200\\) のとき。\n\nsim_18 &lt;- replicate(n_sims, smp_test_2(N = 200, level = 0.05, mu = 2, sigma = 3))\ntable(sim_18) / n_sims\n\nsim_18\nalt \n  1 \n\n\nこのように、標本サイズを大きくすると、第2種の誤りの確率は下がる。したがって、統計的検定における誤りの確率を減らすためには、有意水準を小さくし、標本サイズを大きくすることが重要になる（しかし、このことは、標本サイズさえ大きくすれば、些細な違いも検出されてしまうということも意味しているので、実用上は注意が必要である）。"
  },
  {
    "objectID": "mean-comparison.html#sec-ttest",
    "href": "mean-comparison.html#sec-ttest",
    "title": "\n11  統計的検定と平均値の比較\n",
    "section": "\n11.3 平均値の差の検定",
    "text": "11.3 平均値の差の検定\n2つのグループの平均値に差があるかどうか、統計的検定で判断しよう。これまで同様、t.test() を使って\\(t\\)検定を行うが、問題によって指定しなけばいけない引数が異なるので注意が必要である。\n\n11.3.1 対応のないデータの平均値の差の検定\n例題： 2つのコーヒーチェーンで、どちらのコーヒーが美味しいか調べるため、無作為に選んだ10人にD店のコーヒーを、無作為に選んだ別の10人にS店のコーヒーを飲んでもらった。10点満点で点数をつけてもらったところ、次のようなデータが得られた。\n\nd &lt;- c(8, 7, 8, 6, 4, 8, 9, 10, 7, 7)\ns &lt;- c(6, 10, 3, 10, 4, 4, 5, 7, 2, 6)\n\nd とs がそれぞれのコーヒーに対する10人の評価である。D店のコーヒーを飲んだ10人と、S店のコーヒーを飲んだ10人は異なるので、これは対応のないデータであると考えられる。\n2つの店のコーヒーの味に対する評価の平均値は、\n\nmean(d)\n\n[1] 7.4\n\nmean(s)\n\n[1] 5.7\n\n\nであり、単純に比較すれば、D店のコーヒーの方が美味しいということになりそうである。しかし、この結果は、1つの標本から得られた結果に過ぎない。言い換えると、今回抽出された人たちは、たまたまD店の味を好んだだけかもしれない。そこで、統計的検定の方法を使って、2店の美味しさに違いがあるかどうか判断しよう。\n各コーヒー店のコーヒーの味の評価の母数（パラメタ、真実の値）をそれぞれ \\(D\\) と \\(S\\) とすると、今回検証する仮説は、\n\n帰無仮説：\\(D = S\\)（つまり、\\(D - S = 0\\)）\n対立仮説：\\(D \\neq S\\)（つまり、\\(D - S \\neq 0\\)）\n\nということになる。これを、有意水準5% で検定する。また、2つのグループの分散は異なると仮定する（2つのグループの分散が等しいと仮定できるときは、var.equal = TRUE を指定するが、通常は母分散を知らないので等しいと仮定しない）。\n以下のコマンドで Welch の \\(t\\) 検定を実行する。\n\n(eg_1 &lt;- t.test(d, s, var.equal = FALSE))\n\n\n    Welch Two Sample t-test\n\ndata:  d and s\nt = 1.6953, df = 14.848, p-value = 0.1109\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n -0.4392736  3.8392736\nsample estimates:\nmean of x mean of y \n      7.4       5.7 \n\n\n検定統計量は、1.6953 である。また、この検定に必要な \\(t\\) 分布の自由度 (df) は、14.848 である。この自由度を使って検定に使う臨界値を求めると、\n\nqt(p = 0.05 / 2, df = 14.848)\n\n[1] -2.133352\n\n\nである。\\(|T| = 1.6953 &lt; 2.133352 = |c|\\) だから、帰無仮説は棄却されない。したがって、D店のコーヒーのほうが美味しいとは言えない。\nちなみに、t.test() の結果として表示される95%信頼区間から、検定結果を出すこともできる。 この例では、DとSの差の95%信頼区間が表示されており、それが \\([-0.439, 3.839]\\) である。この区間が0（つまり、2つの美味しさに差がない）を含んでいるので、有意水準5%で帰無仮説を棄却できない。\n\n11.3.2 対応のあるデータの平均値の差の検定\n例題： 2つのコーヒーチェーンで、どちらのコーヒーが美味しいか調べるため、無作為に選んだ10人にD店のコーヒーとS店のコーヒーを1杯ずつ飲んでもらった。それぞれのコーヒーに10点満点で点数をつけてもらったところ、次のようなデータが得られた。\n\nsurvey &lt;- tibble(\n  id = 1:10,\n  d = c(8, 7, 8, 6, 4, 8, 9, 10, 7, 7),\n  s = c(6, 10, 3, 10, 4, 4, 5, 7, 2, 6)\n)\nsurvey\n\n# A tibble: 10 × 3\n      id     d     s\n   &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1     1     8     6\n 2     2     7    10\n 3     3     8     3\n 4     4     6    10\n 5     5     4     4\n 6     6     8     4\n 7     7     9     5\n 8     8    10     7\n 9     9     7     2\n10    10     7     6\n\n\nid は、回答者番号、d はD店のコーヒーに対する評価、s はS店のコーヒーに対する評価である。\n同じ10人がD店のコーヒーとS店のコーヒーの両方を飲んで評価しているので、これは対応のあるデータであると考えられる。\n2つの店のコーヒーの味に対する評価の平均値は、\n\nmean(survey$d)\n\n[1] 7.4\n\nmean(survey$s)\n\n[1] 5.7\n\n\nであり、単純に比較すれば、D店のコーヒーのほうが美味しいということになりそうである。しかし、この結果は、1つの標本から得られた結果に過ぎない。言い換えると、今回抽出された人たちは、たまたまD店の味を好んだだけかもしれない。そこで、統計的検定の方法を使って、2店の美味しさに違いがあるかどうか判断しよう。\n各コーヒー店のコーヒーの味の評価の母数（パラメタ、真実の値）をそれぞれ \\(D\\) と \\(S\\) とすると、今回検証する仮説は、\n\n帰無仮説：\\(D = S\\)（つまり、\\(D - S = 0\\)）\n対立仮説：\\(D \\neq S\\)（つまり、\\(D - S \\neq 0\\)）\n\nということになる。これを、有意水準5% で検証する。対応のあるデータであることをRに伝えるため、paired = TRUE を指定する）。\n\n(eg_2 &lt;- t.test(survey$d, survey$s, paired = TRUE))\n\n\n    Paired t-test\n\ndata:  survey$d and survey$s\nt = 1.6805, df = 9, p-value = 0.1272\nalternative hypothesis: true mean difference is not equal to 0\n95 percent confidence interval:\n -0.5883968  3.9883968\nsample estimates:\nmean difference \n            1.7 \n\n\n検定統計量は、1.6805 である。また、この検定に必要な \\(t\\) 分布の自由度 (df) は、9 である。この自由度を使って検定に使う臨界値を求めると、\n\nqt(p = 0.05 / 2, df = 9)\n\n[1] -2.262157\n\n\nである。\\(|T| = 1.6953 &lt; 2.262157 = |c|\\) だから、帰無仮説は棄却されない。したがって、D店のコーヒーのほうが美味しいとは言えない。\n2つの美味しさの差の95%信頼区間を見てみると、 \\([-0.588, 3.988]\\) である。この区間が0（美味しさに差がない） を含んでいるので、有意水準5%で帰無仮説は棄却されず、保留される。"
  },
  {
    "objectID": "bivariate.html",
    "href": "bivariate.html",
    "title": "\n12  2つの変数の関係を理解する\n",
    "section": "",
    "text": "13 質的変数同士の関係を調べる"
  },
  {
    "objectID": "bivariate.html#sec-prep15",
    "href": "bivariate.html#sec-prep15",
    "title": "\n12  2つの変数の関係を理解する\n",
    "section": "\n12.1 準備",
    "text": "12.1 準備\n必要なパッケージを読み込み、図の日本語が正しく表示されるようにする。\n\nlibrary(tidyverse)\n\n## 図のなかで日本語を使えるようにする\n## フォントの設定はお好みで\n## （Unix/Linux ではIPAexフォントのインストールが必要かも）\nif (.Platform$OS.type == \"windows\") { # Windows\n  library(fontregisterer)\n  my_font &lt;- \"Yu Gothic\"\n} else if (capabilities(\"aqua\")) { # macOS\n  my_font &lt;- \"HiraginoSans-W3\"\n} else { # Unix/Linux\n  my_font &lt;- \"IPAexGothic\"\n}\ntheme_set(theme_gray(base_size = 9,\n                     base_family = my_font))"
  },
  {
    "objectID": "bivariate.html#データの入手",
    "href": "bivariate.html#データの入手",
    "title": "\n12  2つの変数の関係を理解する\n",
    "section": "\n12.2 データの入手",
    "text": "12.2 データの入手\nプロジェクト内に data ディレクトリがない場合は、まずディレクトリを作る。\n\ndir.create(\"data\")\n\n次に、今回の実習で利用するデータ (fake_bivariate.csv) をダウンロードし、プロジェクト内の data フォルダの中に保存する（このデータは架空のものである）。\nこのデータセットを read_csv() で読み込み、 myd という名前で利用する。\n\nmyd &lt;- read_csv(\"data/fake_bivariate.csv\")\n\nRows: 1000 Columns: 5\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\ndbl (5): id, female, support, height, faheight\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nデータセットに含まれる変数を確認しよう。\n\nnames(myd)\n\n[1] \"id\"       \"female\"   \"support\"  \"height\"   \"faheight\"\n\n\nこのデータセットに含まれているのは、以下の変数である。\n\n\nid: 個人のID（識別番号）\n\nfemale: 女性であることを表すダミー変数（男性なら0、女性なら1）\n\nsupport: 内閣を支持することを表すダミー変数（不支持なら0、支持なら1）\n\nheihgt: 身長 (cm)\n\nfaheigt: 父親の身長 (cm)\n\nデータの中身を確認してみよう。\n\nglimpse(myd)\n\nRows: 1,000\nColumns: 5\n$ id       &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18…\n$ female   &lt;dbl&gt; 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1…\n$ support  &lt;dbl&gt; 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0…\n$ height   &lt;dbl&gt; 174.5, 171.3, 174.2, 173.5, 169.7, 157.0, 158.5, 161.5, 164.1…\n$ faheight &lt;dbl&gt; 179.0, 166.4, 169.7, 171.5, 156.5, 163.1, 170.5, 173.8, 180.7…"
  },
  {
    "objectID": "bivariate.html#質的変数",
    "href": "bivariate.html#質的変数",
    "title": "\n12  2つの変数の関係を理解する\n",
    "section": "\n13.1 質的変数",
    "text": "13.1 質的変数\nmyd（読み込んだデータセット） には、女性を表す famale 変数と、内閣に対する支持を表す support 変数がある。これらの変数では、数字自体には特に意味がない。このような変数は、質的変数 (qualitative variables) と呼ばれる。また、female のように、ある特性を備えているかどうかを0 と 1 で表現する変数をダミー変数 (dummy variable) と呼ぶ。female の場合、変数名が female（女性）なので、女性という特性をもっているかどうかを表している。その特性をもっていれば（つまり、女性は）1、もっていなければ（つまり男性は）0で表される。\nデータセットのうち、何人が女性で何人が男性かを調べるために、表を作ってみよう。表は table() で作れる。\n\ntable(myd$female)\n\n\n  0   1 \n500 500 \n\n\n男性 (0) が500人、女性 (1) が500人いることがわかる。\nこのままでも分析はできるが、0と1だと何を表しているのかわかりにくい。そこで、0と1にラベル付けをしよう。質的変数は、factor という型に変形して、ラベルをつけると使いやすい。そのために factor() を使う。\n\nmyd &lt;- myd |&gt; \n  mutate(female = factor(female, \n                         levels = c(0, 1), \n                         labels = c(\"男性\", \"女性\")))\n\nここで、|&gt; はパイプ演算子と呼ばれるのもので、|&gt; の左側で評価した内容を、|&gt; の右側にある関数の第1引数として使う。単純な例として、sqrt(4) は 4 |&gt; sqrt() と書くことができる。試してみよう。\n\nsqrt(4)\n\n[1] 2\n\n4 |&gt; sqrt()\n\n[1] 2\n\n\n実際には、このように単純な計算でパイプを使う必要はないが、プログラムが複雑になると、パイプを使ったほうが楽なことが多くなる。\n\n\n\n\n\n\nNote\n\n\n\nパイプ演算子を入力するためのショートカットは、 - Cmd + Shift + M (macOS) - Control + Shift + M (macOS and Windows) である。\n\n\nもう一度、先ほどと同じように表を作ってみよう。\n\ntable(myd$female)\n\n\n男性 女性 \n 500  500 \n\n\n男性と女性というラベルが付いたことがわかる。\n女性の人数を直接数えるには、次のようにすればよい。\n\nsum(myd$female == \"女性\")\n\n[1] 500\n\n\n一度ラベルをつけてしまうと、元の値は使えなくなるので注意が必要である。たとえば、女性ダミーで値が1の個数を数えると、\n\nsum(myd$female == 1)\n\n[1] 0\n\n\nとなってしまう。\nもう一つの質的変数である内閣への支持も表にしてみよう。\n\ntable(myd$support)\n\n\n  0   1 \n450 550 \n\n\n450人が内閣を不支持、550人が支持していることがわかる。やはり、0と1ではわかりにくいので、ラベルをつけよう。\n\nmyd &lt;- myd |&gt; \n  mutate(support = factor(support, \n                          levels = c(0, 1), \n                          labels = c(\"不支持\", \"支持\")))\n\nもう一度、先ほどと同じように表を作ってみよう。\n\ntable(myd$support)\n\n\n不支持   支持 \n   450    550 \n\n\nラベルをつけることができた。"
  },
  {
    "objectID": "bivariate.html#クロス表",
    "href": "bivariate.html#クロス表",
    "title": "\n12  2つの変数の関係を理解する\n",
    "section": "\n13.2 クロス表",
    "text": "13.2 クロス表\n上で見た2つの質的変数同士には、何か関係があるのだろうか。これを確かめるために、2つの質的変数の関係を表にしてみよう。複数の変数を使った表をクロス表 (corss table, contingency table)と呼ぶ。クロス表も table() で作れる。\n\ntable(myd$female, myd$support) # 行の変数を先に、列の変数を後に書く\n\n      \n       不支持 支持\n  男性    200  300\n  女性    250  250\n\n\nmyd$ をすべての変数につけるのが面倒なときは、with() を使って次のように書くこともできる。\n\nwith(myd, table(female, support))\n\n      support\nfemale 不支持 支持\n  男性    200  300\n  女性    250  250\n\n\n変数名も表示されるので、こちらのほうが便利だろう。\nこの表に名前をつけて保存し、後で使えるようにしよう。\n\ntbl_fem_sup &lt;- with(myd, table(female, support))\n\n男性で内閣不支持が200人、男性で支持するのが300人、女性では不支持も支持も250人ずついることがわかる。\nこの表には、行 (row) や列 (column) ごとの合計値が示されていない。合計値は、あったほうが便利だが、表の中身がわかっていれば計算することができるので、必要不可欠な情報ではない。つまり、合計値は、データにとっては周辺的な情報であるし、物理的に見ても表の周辺に記載されることになるので、周辺度数 (margins) と呼ばれる。表を読む際には周辺度数があったほうがわかりやすいので、addmargins() で周辺度数を加えよう。\n\naddmargins(tbl_fem_sup)\n\n      support\nfemale 不支持 支持  Sum\n  男性    200  300  500\n  女性    250  250  500\n  Sum     450  550 1000\n\n\n表の周辺に合計 (Sum) が加えられた。\n列の周辺度数のみを加えたいときは、margin = 1 を指定する。\n\naddmargins(tbl_fem_sup, margin = 1)\n\n      support\nfemale 不支持 支持\n  男性    200  300\n  女性    250  250\n  Sum     450  550\n\n\n行の周辺度数のみを加えたいときは、margin = 2 を指定する。\n\naddmargins(tbl_fem_sup, margin = 2)\n\n      support\nfemale 不支持 支持 Sum\n  男性    200  300 500\n  女性    250  250 500\n\n\nこの表から、男性の方が内閣支持の割合が大きいことがわかる。\n割合 (proportion) そのものを表示したいときは、作ったテーブルに対して prop.table () を使う。 prop.table() を使うときに注意すべき点が2つある。 まず、何を100パーセントにするのか決める必要がある。 私たちのデータの場合、(1) 男性は男性だけで100パーセント、女性は女性だけで100パーセントにする、(2) 内閣支持者と内閣不支持者をそれぞれ100パーセントにする、(3) 全体（1,000人）を100パーセントにするという3通りが考えられる。私たちの表では、性別が行に、内閣の支持が列に表示されているので、(1) の場合を行パーセント、(2) を列パーセント、 (3) を全体パーセント と呼ぶ。\nここでは、「性別によって内閣支持に違いがあるか」を調べたいとしよう。行にある変数である性別ごとの違いを知りたいので、行パーセントを指定する。行パーセント計算するときは、margin = 1 を指定する（列パーセントは margin = 2、全体パーセントは margin を指定しない）。addmargin() と margin 指定の方法が異なるので、注意が必要である。\n第2に、周辺度数を加える場合は、行と列のうち、原因として注目していないほうの周辺度数は、prop.table() を使う前に、注目している方の周辺度数は prop.table() より後に加えた方がよい。私たちは性別（行変数）による違いに注目しているので、\n\n列（内閣支持）の周辺度数を加える\n割合を計算する\n行（性別）の周辺度数を加える\n\nという順番で表を作った方がよい。そのためには、次のようにすればよい。\n\n(tbl_fem_sup_m1 &lt;- addmargins(tbl_fem_sup, margin = 1))    # 列周辺度数を加える\n\n      support\nfemale 不支持 支持\n  男性    200  300\n  女性    250  250\n  Sum     450  550\n\n(tbl_fem_sup_p &lt;- prop.table(tbl_fem_sup_m1, margin = 1))  # 行パーセントで割合に変換する \n\n      support\nfemale 不支持 支持\n  男性   0.40 0.60\n  女性   0.50 0.50\n  Sum    0.45 0.55\n\n(tbl_fem_sup_2 &lt;- addmargins(tbl_fem_sup_p, margin = 2))   # 行周辺度数を加える\n\n      support\nfemale 不支持 支持  Sum\n  男性   0.40 0.60 1.00\n  女性   0.50 0.50 1.00\n  Sum    0.45 0.55 1.00\n\n\nパーセント表示にしたいときは、100をかければよい。\n\n(tbl_fem_sup_3 &lt;- tbl_fem_sup_2 * 100)\n\n      support\nfemale 不支持 支持 Sum\n  男性     40   60 100\n  女性     50   50 100\n  Sum      45   55 100\n\n\n男性の内閣支持率は60%、女性の内閣支持率は50%であることがわかる。"
  },
  {
    "objectID": "bivariate.html#独立性の検定",
    "href": "bivariate.html#独立性の検定",
    "title": "\n12  2つの変数の関係を理解する\n",
    "section": "\n13.3 独立性の検定",
    "text": "13.3 独立性の検定\n私たちの標本（データ）では、女性の内閣支持率より、男性の内閣支持率の方が高い。これはたまたま得られた結果だろうか。それとも、母集団でも男性の内閣支持率の方が高いと考えられるだろうか。\nこれを確かめるために、統計的検定を行う。ここで検証する仮説は、以下のものである。\n\n帰無仮説：性別と内閣支持率は独立である（つまり、男性の内閣支持率と女性の内閣支持率に差はない）\n対立仮説：性別と内閣支持率には関連がある [独立ではない] （つまり、男性の内閣支持率 \\(\\neq\\) 女性の内閣支持率）\n\nこの検定は、2つの変数が独立である（帰無仮説）か、独立でない（対立仮説）かを確かめるので、独立性の検定 と呼ばれる。また、検定に \\(\\chi^2\\) （カイ二乗）分布を使うので、\\(\\chi^2\\) 検定 と呼ばれることもある（英語では、\\(\\chi^2\\) [chi-square] test of independence と呼ばれる）。\n検定で使うカイ二乗分布の自由度は、分析する表の \\((行数 - 1) \\times (列数 - 1)\\) である。周辺度数を除くと、私たちの表は2行（男性または女性）\\(\\times\\) 2列（不支持または支持）なので、自由度 \\((2-1)(2-1) = 1\\) のカイ二乗分布を利用する。\n有意水準を7% に設定すると、検定に使う臨界値は、qchisq() を使って、\n\nqchisq(p = 0.07, df = 1, lower.tail = FALSE)\n\n[1] 3.28302\n\n\nということがわかる。検定統計量がこの臨界値より大きいとき、私たちは帰無仮説を棄却する。 反対に、検定統計量がこの臨界値以下のとき、私たちは帰無仮説を棄却しない。\n検定統計量は、chisq.test() で計算できる（\\(\\ast\\) イェーツの連続性補正は行わないので correct = FALSE とする）。\n\nchisq.test(myd$female, myd$support, correct = FALSE)\n\n\n    Pearson's Chi-squared test\n\ndata:  myd$female and myd$support\nX-squared = 10.101, df = 1, p-value = 0.001482\n\n\nX-squared が検定統計量である。ここでは、10.101 という値が得られた。この値は、有意水準7%での臨界値である3.28302 より大きいので、帰無仮説は棄却される。\nしたがって、内閣支持率は性別よって異なり、男性の方が女性よりも内閣を支持するという判断を下す。"
  },
  {
    "objectID": "bivariate.html#カイ二乗分布を理解する",
    "href": "bivariate.html#カイ二乗分布を理解する",
    "title": "\n12  2つの変数の関係を理解する\n",
    "section": "\n13.4 カイ二乗分布を理解する",
    "text": "13.4 カイ二乗分布を理解する\nカイ二乗 (\\(\\chi^2\\)) 分布は、自由度 \\(df \\geq 1\\) によってその形を変える。\nたとえば、自由度1, 3, 5, 10のカイ二乗分布は、以下のように分布する。\n\nx &lt;- seq(0, 20, length = 1000)\nchi1  &lt;- dchisq(x, df =  1)\nchi3  &lt;- dchisq(x, df =  3)\nchi5  &lt;- dchisq(x, df =  5)\nchi10 &lt;- dchisq(x, df = 10)\ndf_chisq &lt;- tibble(\n  x = rep(x, 4),\n  chisq = c(chi1, chi3, chi5, chi10),\n  group = rep(c(\"df = 1\", \"df = 3\", \"df = 5\", \"df = 10\"), rep(1000, 4)))\ndens_chisq &lt;- ggplot(df_chisq, aes(x = x, y = chisq,\n                                   color = group, linetype = group)) +\n  geom_line() +\n  xlim(0, 15) + ylim(0, .5) +\n  labs(x = \"\", y = \"確率密度\") +\n  scale_color_discrete(name = \"自由度 (df)\") +\n  scale_linetype_discrete(name = \"自由度 (df)\")\nplot(dens_chisq)\n\nWarning: Removed 1000 rows containing missing values (`geom_line()`).\n\n\n\n\n\nカイ二乗分布の形状を確認するための関数を用意したので、これを使って色々なカイ二乗分布の形状を確認してみよう（この関数の中身を理解する必要はない）。\n\nplot_chisq &lt;- function(df) {\n  upper &lt;- max(c(df + 10, df*2))\n  x &lt;- seq(from = 0, to = upper, length = 1000)\n  chisq &lt;- dchisq(x, df = df)\n  p &lt;- ggplot(tibble(x, chisq), aes(x = x, y = chisq)) +\n    geom_line(color = \"royalblue\") +\n    labs(x = \"\", y = \"確率密度\",\n         title = paste(\"自由度\", df, \"のカイ二乗分布\"))\n  plot(p)\n}\n\n自由度1のカイ二乗分布は、\n\nplot_chisq(df = 1)\n\n\n\n\n自由度3のカイ二乗分布は、\n\nplot_chisq(df = 3)\n\n\n\n\n実習課題：自由度 (df) の値をによって、カイ二乗分布がどのように変化するか確かめてみよう。"
  },
  {
    "objectID": "bivariate.html#量的変数",
    "href": "bivariate.html#量的変数",
    "title": "\n12  2つの変数の関係を理解する\n",
    "section": "\n14.1 量的変数",
    "text": "14.1 量的変数\n私たちのデータセットには、height（身長）と faheight（父親の身長） という2つの量的変数（quantitative variables）がある。量的変数とは、簡単にいうと、数値自体に意味がある変数である。\n量的変数を調べるときは、ます、基本的な統計量とヒストグラムを確認する。 まず、height の統計量を確認する。\n\nmean(myd$height)\n\n[1] 165.8727\n\nmedian(myd$height)\n\n[1] 166.15\n\nvar(myd$height)\n\n[1] 53.41806\n\nsd(myd$height)\n\n[1] 7.308766\n\n\nヒストグラムを作る。\n\nh_height &lt;- ggplot(myd, aes(x = height)) +\n  geom_histogram(color = \"black\", fill = \"dodgerblue\") +\n  labs(x = \"身長 (cm)\", y = \"度数\")\nplot(h_height)\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\nヒストグラムに山が2つある。なぜだろうか？\nこのデータが身長のデータであり、男女共データに含まれていることを考えると、性別によって分布の山が変わりそうである。男女別にヒストグラムを作ってみよう。\n\nh_height_gender &lt;- h_height +\n  facet_grid(row = vars(female))\nplot(h_height_gender)\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\nやはり、性別によって分布が異なることがわかる。このようなことがわかるので、データ分析の前に必ずヒストグラムを確認する習慣をつけてほしい。\n同様に、faheight の統計量を確認する。\n\nmean(myd$faheight)\n\n[1] 169.7533\n\nmedian(myd$faheight)\n\n[1] 169.6\n\nvar(myd$faheight)\n\n[1] 31.34405\n\nsd(myd$faheight)\n\n[1] 5.598576\n\n\nヒストグラムを作る。\n\nh_father &lt;- ggplot(myd, aes(x = faheight)) +\n  geom_histogram(color = \"black\", fill = \"tomato\") +\n  labs(x = \"身長 (cm)\", y = \"度数\")\nplot(h_father)\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n父親の身長は、（当たり前だが）子の性別によって変わることはないので、分布の山は1つである。"
  },
  {
    "objectID": "bivariate.html#質的変数と量的変数の関係",
    "href": "bivariate.html#質的変数と量的変数の関係",
    "title": "\n12  2つの変数の関係を理解する\n",
    "section": "\n14.2 質的変数と量的変数の関係",
    "text": "14.2 質的変数と量的変数の関係\n身長のヒストグラムから明らかになったように、性別（質的変数）と身長（量的変数）の間に関係がありそうである。 質的変数と量的変数の関係は、図示すると理解しやすい。箱ひげ図 (box-and-whisker plot または単に box plot) とバイオリン図 (violin plot) と呼ばれる図を作って確認してみよう。\n\nvb1 &lt;- ggplot(myd, aes(x = female, y = height)) +\n  geom_violin() +\n  geom_boxplot(fill = \"gray\", width = 0.5) +\n  labs(x = \"性別\", y = \"身長 (cm)\")\nplot(vb1)\n\n\n\n\nこの図は、箱がデータの中心50%分を表している。箱の中にある太い線は、中央値（50パーセンタイル、第2四分位）である。箱の下端が第1四分位（25パーセンタイル）、箱の上端が第3四分位（75パーセンタイル）を示している。また、箱から上下に伸びている線がひげである。ひげの下端が最小値（外れ値を除く）であり、上端が最大値（外れ値を除く）である。ひげよりも外側にある点は外れ値（outlier）である。\n\\(\\ast\\)（第3四分位数（箱の上端）より、1.5\\(\\times\\)IQR以上大きい値、または第1四分位数（箱の下端）より、1.5\\(\\times\\)IQR 以上小さい値が外れ値と見なされる。ただし、IQR（interquartile range, 四分位範囲）とは、第3四分位と第1四分位の差（図で考えると、箱の高さ）である。）\nこの図を見ると、男性の身長の分布と女性の身長の分布は異なる分布であり、男性の身長のほうが高いようである。\nしかし、これはあくまで標本の分布であり、母集団でも同じことが言えるかどうかは検定で確かめる必要がある。 これを確かめるためには、平均値の差の検定（この場合は ウェルチ (Welch) の \\(t\\) 検定）を行う必要がある。"
  },
  {
    "objectID": "bivariate.html#量的変数同士の関係",
    "href": "bivariate.html#量的変数同士の関係",
    "title": "\n12  2つの変数の関係を理解する\n",
    "section": "\n14.3 量的変数同士の関係",
    "text": "14.3 量的変数同士の関係\n次に量的変数同士（height とfaheight）の関係を確かめてみよう。\nまず、2つの関係を図示する。2つの量的変数同士の関係は、散布図 (scatter plot) を使って図示する。geom_point() で散布図が描ける。\n\nscat1 &lt;- ggplot(myd, aes(x = faheight, y = height)) +\n  geom_point() +\n  labs(x = \"父親の身長 (cm)\", y = \"本人の身長 (cm)\")\nplot(scat1)\n\n\n\n\nこの図を見ると、父親の身長が高いほど、子の身長が高いという関係がありそうだ。ヒストグラムで確認したように、データには男女が含まれているが、性別によって身長の分布が異なり、点が2つのグループに分かれていることがわかる。\n次に、2変数の直線的な関係の強さを測るために、相関係数 (correlation coefficient) を計算してみよう。cor() を使う。\n\nwith(myd, cor(height, faheight))\n\n[1] 0.2394457\n\n\n相関係数は約0.24であり、弱い正の相関があるようである。\n図から得られた情報と相関係数から得られた情報は整合的だろうか。 相関係数だけ見ると、父親の身長と子の身長にはあまり強い関係はなさそうだという結論になる。 しかし、散布図を見ると、2変数の間には非常に強い関係がありそうである。\n図からわかる通り、散布図の点は2つのグループに分かれている。男女を色と形で区別して散布図を作り直してみよう。\n\nscat2 &lt;- ggplot(myd, aes(x = faheight, y = height, \n                         color = female, shape = female)) +\n  geom_point() +\n  labs(x = \"父親の身長 (cm)\", y = \"本人の身長 (cm)\") +\n  scale_color_brewer(palette = \"Set1\", name = \"性別\", labels = c(\"男性\", \"女性\")) +\n  scale_shape_discrete(name = \"性別\", labels = c(\"男性\", \"女性\"))\nplot(scat2)\n\n\n\n\nこの図からわかる通り、性別ごとにグループができている。\n男女別にして相関係数を求め直そう。 まず、女性の場合について求める。filter() を使うと、女性だけ簡単に抜き出せる。\n\nmyd |&gt; \n  filter(female == \"女性\") |&gt; \n  with(cor(height, faheight)) |&gt; \n  round(digits = 2)\n\n[1] 0.81\n\n\nこのコマンドは、パイプを使わないと次のように書ける。\n\nround(with(filter(myd, female == \"女性\"), cor(height, faheight)), digits = 2)\n\n[1] 0.81\n\n\nパイプを使ったほうがコードが読みやすい。\nこの結果から、女性については父親の身長と本人の身長の間に強い正の相関があることがわかる。\n男性はどうだろうか。\n\nmyd |&gt; \n  filter(female == \"男性\")　 |&gt; \n  with(cor(height, faheight)) |&gt; \n  round(digits = 2)\n\n[1] 0.81\n\n\nやはり強い正の相関がある。\nこの例からわかる通り、単に相関係数だけを求めると、2変数の関係を見誤る可能性がある。反対に、散布図だけに頼ると、ありもしないパタンを「見つけて」しまうことがある（偶然できた壁のシミが顔に見えることがあるように、人間は意味のないパタンを認識し易い）。 したがって、2つ（以上）の量的変数の関係について調べるときは、散布図と相関係数をセットで使うことが重要である。"
  }
]